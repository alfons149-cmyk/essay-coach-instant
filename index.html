<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>EssayCoach – Cambridge Toolkit</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      max-width: 800px;
      margin: auto;
      padding: 20px;
    }
    textarea {
      width: 100%;
      padding: 8px;
      margin-bottom: 10px;
    }
    button {
      padding: 8px 14px;
      margin-right: 5px;
      cursor: pointer;
    }
    .notes {
      margin-top: 10px;
      background: #f4f4f4;
      padding: 10px;
      border-radius: 4px;
    }
  </style>
</head>
<body>
  <h1>EssayCoach – Cambridge Toolkit</h1>
  <p>Write or paste your essay below. The tool will help you formalise and improve sentences.</p>

  <textarea id="inputText" rows="8" placeholder="Type here..."></textarea><br>
  <label>
    Level:
    <select id="levelSelect">
      <option value="B2">B2 First</option>
      <option value="C1">C1/C2 Advanced</option>
    </select>
  </label>
  <button onclick="runCorrection()">Correct</button>
  <button onclick="downloadPDF()">Export PDF</button>
  <button onclick="clearAll()">Clear</button>

  <h2>Corrected Output:</h2>
  <textarea id="outputText" rows="8" readonly></textarea>

  <div class="notes" id="notes"></div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <script>
  // --- Smarter, clause-aware corrector with conjunctive adverbs ---
  const correct = (text, lvl) => {
    if (!text || !text.trim()) return { out: "", notes: [] };
    let out = text.trim();
    const notes = [];

    // 1) Expand common contractions
    const CONTRACTIONS = {
      "can't": "cannot","won't": "will not","don't": "do not","doesn't": "does not","didn't": "did not",
      "isn't": "is not","aren't": "are not","it's": "it is","I'm": "I am","you're": "you are",
      "we're": "we are","they're": "they are","I've": "I have","we've": "we have","they've": "they have",
    };
    Object.entries(CONTRACTIONS).forEach(([k, v]) => {
      const re = new RegExp(`\\b${k.replace(/[-/\\^$*+?.()|[\\]{}]/g, "\\\\$&")}\\b`, "gi");
      const before = out;
      out = out.replace(re, (m) =>
        m[0] === m[0].toUpperCase() ? v[0].toUpperCase() + v.slice(1) : v
      );
      if (out !== before) notes.push("Expanded contractions for formality.");
    });

    // 2) Replace informal words & remove fillers
    const SLANG = [
      { re: /\\bkids\\b/gi, rep: "children" },
      { re: /\\ba lot of\\b/gi, rep: "many" },
      { re: /\\bgonna\\b/gi, rep: "going to" },
      { re: /\\bwanna\\b/gi, rep: "want to" },
      { re: /\\bstuff\\b/gi, rep: "items" },
      { re: /\\bthings\\b/gi, rep: "aspects" },
      { re: /\\breally|very\\b/gi, rep: "" },
    ];
    SLANG.forEach(({ re, rep }) => { if (re.test(out)) { out = out.replace(re, rep); notes.push("Adjusted informal phrasing."); }});

    const VAGUE = [
      { re: /\\bget\\b/gi, rep: "obtain" },
      { re: /\\bdo\\b/gi, rep: "carry out" },
      { re: /\\bmake\\b/gi, rep: "create" },
      { re: /\\bsay\\b/gi, rep: "state" },
    ];
    VAGUE.forEach(({ re, rep }) => { if (re.test(out)) { out = out.replace(re, rep); notes.push("Replaced vague verb."); }});

    const FILLERS = [/\\blike,?\\b/gi, /\\byou know\\b/gi, /\\bI mean\\b/gi, /\\bjust\\b/gi];
    FILLERS.forEach((re) => { if (re.test(out)) { out = out.replace(re, ""); notes.push("Removed fillers."); }});

    // 3) Normalise spaces & punctuation
    const beforeSpace = out;
    out = out
      .replace(/\\s+([,;:.!?])/g, "$1")
      .replace(/([,;:.!?])(\\S)/g, "$1 $2")
      .replace(/\\s{2,}/g, " ");
    if (out !== beforeSpace) notes.push("Normalised spacing.");

    // 4) Capitalise sentence starts
    const beforeCap = out;
    out = out.replace(/(^|[.!?]\\s+)([a-z])/g, (m, p1, p2) => p1 + p2.toUpperCase());
    if (out !== beforeCap) notes.push("Capitalised sentence start.");

    // 5) Clause-aware punctuation: FANBOYS + conjunctive adverbs
    const FANBOYS = ["for","and","nor","but","or","yet","so"];
    const SUBORD = ["although","though","because","since","when","while","if","unless","after","before","once","whereas","as"];
    const CADV = ["however","therefore","moreover","nevertheless","consequently","furthermore","nonetheless","accordingly","thus","otherwise","meanwhile","instead","still"];

    const hasFiniteVerb = (s) => {
      const aux = /\\b(am|is|are|was|were|be|been|being|do|does|did|has|have|had|can|could|will|would|shall|should|may|might|must)\\b/i;
      const finite = /\\b\\w+(ed|s)\\b/i;
      return aux.test(s) || finite.test(s);
    };

    const addCommasHeuristically = (text) => {
      return text.replace(/([^.!?]+)([.!?]|$)/g, (m, core, end) => {
        let s = core.trim();

        // A) Fronted subordinate clause → add comma if missing
        const firstWord = (s.match(/^\\w+/) || [""])[0].toLowerCase();
        if (SUBORD.includes(firstWord) && !/,/.test(s)) {
          const tokens = s.split(/\\s+/);
          const starters = ["i","you","he","she","we","they","it","the","a","an","this","that","these","those","many","most","some"];
          let insertAt = -1;
          for (let i = 3; i < Math.min(tokens.length, 20); i++) {
            if (starters.includes(tokens[i]?.toLowerCase())) { insertAt = i; break; }
          }
          if (insertAt > -1) {
            tokens.splice(insertAt, 0, ",");
            s = tokens.join(" ");
          }
        }

        // B) Independent clause ,/Ø FANBOYS independent clause → add comma before FANBOYS
        FANBOYS.forEach((cj) => {
          const idx = s.toLowerCase().indexOf(` ${cj} `);
          if (idx > -1 && !new RegExp(`,\\s+${cj}\\b`, "i").test(s)) {
            const left = s.slice(0, idx).trim();
            const right = s.slice(idx + cj.length + 2).trim();
            if (hasFiniteVerb(left) && hasFiniteVerb(right)) {
              s = left.replace(/\\s+$/, "") + ", " + cj + " " + right.replace(/^,?\\s*/, "");
            }
          }
        });

        // C) Independent clause + conjunctive adverb + independent clause
        // → enforce "; however, " style
        CADV.forEach((adv) => {
          const re = new RegExp(`\\b${adv}\\b`, "i");
          const m2 = s.match(re);
          if (m2) {
            const idx = m2.index;
            const word = m2[0];
            const left = s.slice(0, idx).trim();
            const right = s.slice(idx + word.length).trim();
            // Only if both sides look like full clauses
            if (hasFiniteVerb(left) && hasFiniteVerb(right)) {
              const leftClean = left.replace(/[\\s,;]+$/, "");
              const rightClean = right.replace(/^[,\\s]+/, "");
              s = `${leftClean}; ${word}, ${rightClean}`;
            }
          }
        });

        return s + (end || "");
      });
    };

    const beforeClause = out;
    out = addCommasHeuristically(out);
    if (out !== beforeClause) notes.push("Inserted clause punctuation (commas/semicolons).");

    // 6) Ensure final punctuation
    if (!/[.!?]$/.test(out)) { out += "."; notes.push("Added final full stop."); }

    // 7) Level tweak (simplify for B2)
    if (lvl === "B2") {
      const beforeLvl = out;
      out = out.replace(/\\bnotwithstanding\\b/gi, "however");
      if (out !== beforeLvl) notes.push("Simplified advanced connector for B2.");
    }

    return { out: out.trim(), notes };
  };
</script>
<script>
  function clearAll() {
    document.getElementById("inputText").value = "";
    document.getElementById("outputText").value = "";
    document.getElementById("notes").innerHTML = "";
  }
</script>
<script>
  function clearAll() {
    document.getElementById("inputText").value = "";
    document.getElementById("outputText").value = "";
    document.getElementById("notes").innerHTML = "";
  }
</script>
  </body>
</html>
