<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>EssayCoach – Cambridge Toolkit (Instant)</title>
  <style>
    :root { --b:#111; --bg:#f6f7fb; --card:#fff; --muted:#6b7280; --border:#e5e7eb; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; margin: 0; background: var(--bg); color:#111; }
    .wrap { max-width: 900px; margin: 0 auto; padding: 24px; }
    h1 { margin: 0 0 6px; }
    .sub { color: var(--muted); margin: 0 0 16px; }
    .card { background: var(--card); border:1px solid var(--border); border-radius:14px; padding:16px; }
    .row { display:flex; gap:8px; flex-wrap: wrap; }
    textarea, select, button { font: inherit; padding: 10px 12px; border:1px solid var(--border); border-radius:10px; }
    textarea { width: 100%; resize: vertical; background:#fff; }
    button { background:#fff; cursor:pointer; }
    button.primary { background: var(--b); color:#fff; border-color: var(--b); }
    .notes { margin-top: 10px; background: #f3f4f6; padding: 10px; border-radius: 10px; border:1px solid var(--border); }
    .hint { color: var(--muted); font-size: 12px; margin-top: 6px; }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>EssayCoach – Cambridge Toolkit</h1>
    <p class="sub">Paste a sentence/paragraph, choose level, and click Correct. Export to PDF or Clear anytime.</p>

    <div class="card" style="margin-bottom:12px">
      <label style="display:block; margin-bottom:8px">
        <div style="color:#6b7280; font-size:14px; margin-bottom:6px">Level</div>
        <select id="levelSelect">
          <option value="B2">B2 First</option>
          <option value="C1">C1/C2 Advanced</option>
        </select>
      </label>

      <label style="display:block; margin-top:10px">
        <div style="color:#6b7280; font-size:14px; margin-bottom:6px">Input</div>
        <textarea id="inputText" rows="6" placeholder="Type or paste your text here..."></textarea>
      </label>

      <div class="row" style="margin-top:10px">
        <button class="primary" onclick="runCorrection()">Correct</button>
        <button onclick="downloadPDF()">Export PDF</button>
        <button onclick="clearAll()">Clear</button>
      </div>

      <div class="hint">Try: “It was late however we continued the discussion” → “It was late; however, we continued the discussion.”</div>
    </div>

    <div class="card">
      <div style="color:#6b7280; font-size:14px; margin-bottom:6px">Corrected Output</div>
      <textarea id="outputText" rows="6" readonly placeholder="Your corrected text will appear here..."></textarea>

      <div class="notes" id="notes"><b>Changes:</b><br><span class="hint">Corrections will appear here after you click “Correct”.</span></div>
    </div>
  </div>

  <!-- Reliable jsPDF CDN -->
  <script src="https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js" crossorigin="anonymous"></script>

  <script>
    // === Utilities ===
    const hasFiniteVerb = (s) => {
      const aux = /\b(am|is|are|was|were|be|been|being|do|does|did|has|have|had|can|could|will|would|shall|should|may|might|must)\b/i;
      const finite = /\b\w+(ed|s)\b/i;     // walked, writes, continues, etc.
      return aux.test(s) || finite.test(s);
    };

    // === Main corrector (with conjunctive adverbs + FANBOYS + subordination) ===
    const correct = (text, lvl) => {
      if (!text || !text.trim()) return { out: "", notes: [] };
      let out = text.trim();
      const notes = [];

      // 1) Contractions → formal
      const CONTRACTIONS = {
        "can't": "cannot","won't": "will not","don't": "do not","doesn't": "does not","didn't": "did not",
        "isn't": "is not","aren't": "are not","it's": "it is","I'm": "I am","you're": "you are",
        "we're": "we are","they're": "they are","I've": "I have","we've": "we have","they've": "they have"
      };
      for (const [k,v] of Object.entries(CONTRACTIONS)) {
        const re = new RegExp(`\\b${k.replace(/[-/\\^$*+?.()|[\\]{}]/g, "\\$&")}\\b`, "gi");
        const before = out;
        out = out.replace(re, (m) => (m[0] === m[0].toUpperCase() ? v[0].toUpperCase()+v.slice(1) : v));
        if (out !== before) notes.push("Expanded contractions for formality.");
      }

      // 2) Informality / fillers
      [
        { re:/\bkids\b/gi, rep:"children" },
        { re:/\ba lot of\b/gi, rep:"many" },
        { re:/\bgonna\b/gi, rep:"going to" },
        { re:/\bwanna\b/gi, rep:"want to" },
        { re:/\bstuff\b/gi, rep:"items" },
        { re:/\bthings\b/gi, rep:"aspects" },
        { re:/\breally|very\b/gi, rep:"" },
      ].forEach(({re,rep}) => { if (re.test(out)) { out = out.replace(re,rep); notes.push("Adjusted informal phrasing."); }});
      [
        { re:/\bget\b/gi, rep:"obtain" },
        { re:/\bdo\b/gi, rep:"carry out" },
        { re:/\bmake\b/gi, rep:"create" },
        { re:/\bsay\b/gi, rep:"state" },
      ].forEach(({re,rep}) => { if (re.test(out)) { out = out.replace(re,rep); notes.push("Replaced vague verb."); }});
      [/\blike,?\b/gi, /\byou know\b/gi, /\bI mean\b/gi, /\bjust\b/gi].forEach((re) => {
        if (re.test(out)) { out = out.replace(re,""); notes.push("Removed fillers."); }
      });

      // 3) Trim spacing around punctuation
      const beforeSpace = out;
      out = out.replace(/\s+([,;:.!?])/g,"$1").replace(/([,;:.!?])(\S)/g,"$1 $2").replace(/\s{2,}/g," ");
      if (out !== beforeSpace) notes.push("Normalised spacing.");

      // 4) Capitalise sentence starts
      const beforeCap = out;
      out = out.replace(/(^|[.!?]\s+)([a-z])/g, (m,p1,p2)=> p1 + p2.toUpperCase());
      if (out !== beforeCap) notes.push("Capitalised sentence start.");

      // 5) Clause punctuation
      const FANBOYS = ["for","and","nor","but","or","yet","so"];
      const SUBORD  = ["although","though","because","since","when","while","if","unless","after","before","once","whereas","as"];
      const CADV    = ["however","therefore","moreover","nevertheless","consequently","furthermore","nonetheless","accordingly","thus","otherwise","meanwhile","instead","still"];

      const punctuateClauses = (text) =>
        text.replace(/([^.!?]+)([.!?]|$)/g, (m, core, end) => {
          let s = core.trim();

          // A) Conjunctive adverb between two clauses → "; however, "
          // We look for any CADV word and rebuild around it if both sides look like clauses.
          for (const adv of CADV) {
            const re = new RegExp(`\\b${adv}\\b`, "i");
            const hit = s.match(re);
            if (hit) {
              const idx = hit.index;
              const word = hit[0];
              const left = s.slice(0, idx).replace(/[ ,;]+$/,"").trim();
              const right = s.slice(idx + word.length).replace(/^[ ,;]+/,"").trim();
              if (hasFiniteVerb(left) && hasFiniteVerb(right)) {
                s = `${left}; ${word}, ${right}`;
                break; // one CADV per sentence handled is enough
              }
            }
          }

          // B) Fronted subordinate clause → comma after it (if missing)
          const firstWord = (s.match(/^\w+/) || [""])[0].toLowerCase();
          if (SUBORD.includes(firstWord) && !/,/.test(s)) {
            const tokens = s.split(/\s+/);
            const starters = ["i","you","he","she","we","they","it","the","a","an","this","that","these","those","many","most","some"];
            let insertAt = -1;
            for (let i = 3; i < Math.min(tokens.length, 20); i++) {
              if (starters.includes(tokens[i]?.toLowerCase())) { insertAt = i; break; }
            }
            if (insertAt > -1) {
              tokens.splice(insertAt, 0, ",");
              s = tokens.join(" ");
            }
          }

          // C) Independent ,/Ø FANBOYS independent → ensure comma before FANBOYS
          for (const cj of FANBOYS) {
            const pos = s.toLowerCase().indexOf(` ${cj} `);
            if (pos > -1 && !new RegExp(`,\\s+${cj}\\b`, "i").test(s)) {
              const left = s.slice(0, pos).trim();
              const right = s.slice(pos + cj.length + 2).trim();
              if (hasFiniteVerb(left) && hasFiniteVerb(right)) {
                s = left.replace(/\s+$/,"") + ", " + cj + " " + right.replace(/^,?\s*/, "");
              }
            }
          }

          return s + (end || "");
        });

      const beforeClause = out;
      out = punctuateClauses(out);
      if (out !== beforeClause) notes.push("Inserted clause punctuation (commas/semicolons).");

      // 6) Final punctuation
      if (!/[.!?]$/.test(out)) { out += "."; notes.push("Added final full stop."); }

      // 7) Level tweak
      if (lvl === "B2") {
        const beforeLvl = out;
        out = out.replace(/\bnotwithstanding\b/gi, "however");
        if (out !== beforeLvl) notes.push("Simplified advanced connector for B2.");
      }

      return { out: out.trim(), notes };
    };

    // === Button handlers (global) ===
    window.runCorrection = function () {
      try {
        const text = document.getElementById("inputText").value;
        const lvl  = document.getElementById("levelSelect").value;
        const { out, notes } = correct(text, lvl);
        document.getElementById("outputText").value = out;
        document.getElementById("notes").innerHTML =
          "<b>Changes:</b><br>" + (notes.length ? notes.map(n => "• " + n).join("<br>") : "(No changes)");
      } catch (e) {
        alert("Error while correcting: " + e.message);
        console.error(e);
      }
    };

    window.clearAll = function () {
      document.getElementById("inputText").value = "";
      document.getElementById("outputText").value = "";
      document.getElementById("notes").innerHTML = "<b>Changes:</b><br><span class='hint'>Cleared.</span>";
    };

    window.downloadPDF = function () {
      try {
        const { jsPDF } = window.jspdf || {};
        if (!jsPDF) { alert("PDF library failed to load. Please check your connection."); return; }
        const doc = new jsPDF({ unit: "pt", format: "a4" });
        const text = document.getElementById("outputText").value || "(empty)";
        const margin = 48;
        let y = margin;

        doc.setFont("Helvetica", "bold"); doc.setFontSize(14);
        doc.text("EssayCoach – Corrected Output", margin, y); y += 20;

        doc.setFont("Helvetica", "normal"); doc.setFontSize(12);
        const lines = doc.splitTextToSize(text, 595 - margin*2);
        doc.text(lines, margin, y);

        doc.save("essay-corrected.pdf");
      } catch (e) {
        alert("Could not create PDF: " + e.message);
        console.error(e);
      }
    };
  </script>
  <script>
  if ('serviceWorker' in navigator) {
    window.addEventListener('load', () => {
      navigator.serviceWorker.register('/alfons149-cmyk/sw.js').catch(console.error);
    });
  }
</script>
</body>
</html>
