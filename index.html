<!doctype html>
<html lang="en" data-theme="coral">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>EssayCoach – Cambridge Toolkit (Unified EN/ES)</title>

  <!-- Icons / Manifest (adjust paths as needed) -->
  <link rel="icon" type="image/png" sizes="192x192" href="/essay-coach-instant/icon-192.png">
  <link rel="apple-touch-icon" href="/essay-coach-instant/icon-192.png">
  <link rel="manifest" href="/essay-coach-instant/manifest.webmanifest">

  <!-- Fonts -->
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&family=IBM+Plex+Serif:wght@400;600&display=swap" rel="stylesheet">

  <style>
    :root { --bg:#111; --fg:#eee; --muted:#aaa; --pill:#2b2b2b; --ok:#1e7f4f; --warn:#9a4b00; --card:#191919; --border:#2a2a2a; }
    html[data-theme="coral"] body { background:#0f0f10; color:var(--fg); font-family:Inter,system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif; }
    a { color:#8ecbff; text-decoration:none; }
    .container { max-width:1100px; margin:0 auto; padding:16px; }
    nav.tabs { display:flex; gap:8px; border-bottom:1px solid var(--border); margin-bottom:16px; }
    nav.tabs button { background:transparent; color:var(--fg); border:0; padding:10px 14px; cursor:pointer; border-bottom:3px solid transparent; }
    nav.tabs button.active { border-color:#ff8c69; }
    .row { display:flex; gap:16px; }
    .col { flex:1; }
    .card { background:var(--card); border:1px solid var(--border); border-radius:12px; padding:12px; }
    textarea, select, input[type="text"], input[type="number"], input[type="checkbox"]{ width:100%; background:#101010; color:var(--fg); border:1px solid var(--border); border-radius:8px; padding:10px; }
    textarea { min-height:180px; font-family: "IBM Plex Serif", ui-serif, Georgia, serif; }
    .toolbar { display:flex; gap:8px; flex-wrap:wrap; margin:8px 0 12px; }
    .btn { padding:8px 12px; border-radius:8px; border:1px solid var(--border); background:#1a1a1a; color:var(--fg); cursor:pointer; }
    .btn-primary { background:#ff8c69; border-color:#ff8c69; color:#111; }
    .btn-ghost { background:transparent; }
    .pill { display:inline-block; padding:4px 10px; border-radius:999px; background:var(--pill); color:var(--fg); border:1px solid var(--border); font-size:12px; }
    .pill.ok { background: var(--ok); color:#fff; }
    .pill.warn { background: var(--warn); color:#fff; }
    .hint { color:var(--muted); }
    .hl { background:#444b; border-bottom:2px solid #888; padding:0 2px; }
    #part2Preview { line-height:1.5; background:#0e0e0e; padding:10px; border-radius:8px; border:1px solid var(--border); min-height:120px; }
    .chip { padding:6px 10px; border-radius:999px; border:1px solid var(--border); background:#141414; color:var(--fg); cursor:pointer; margin:4px 6px 0 0; }
    .alt-section { margin-bottom:10px; }
    .grid { display:grid; gap:12px; }
    @media (min-width: 900px){
      .grid-2 { grid-template-columns: 1fr 1fr; }
      .grid-3 { grid-template-columns: 1fr 1fr 1fr; }
    }
    .muted { color:var(--muted); }
    .section-title { margin:0 0 8px; font-size:14px; text-transform:uppercase; letter-spacing:.06em; color:#ffb29c; }
  </style>

  <!-- Optional: basic i18n stub (replace with your real window.t implementation) -->
  <script>
    window.t = window.t || (k => {
      // Return falsy to allow the JS to fall back to built-in English strings.
      return null;
    });
    // Set this to your Worker endpoint to enable AI mode
    // window.AI_ENDPOINT = "https://your-worker.example.com/correct";
  </script>
</head>
<body>
  <div class="container">
    <header class="row" style="align-items:center; justify-content:space-between; gap:8px;">
      <h1 style="margin:8px 0;">EssayCoach – Cambridge Toolkit</h1>
      <div id="timer" class="pill">Timer: 00:00</div>
    </header>

    <!-- Tabs -->
    <nav class="tabs">
      <button id="tab-scaffolds" class="active">Scaffolds</button>
      <button id="tab-corrector">Corrector (Part 1)</button>
      <button id="tab-punct">Punctuation</button>
      <button id="tab-part2">Part 2 (Letters/Reports…)</button>
    </nav>

    <!-- Views -->
    <main>
      <!-- Scaffolds view -->
      <section id="view-scaffolds" class="card">
        <h3 class="section-title">Scaffolds</h3>
        <p class="muted">Scaffold content goes here. (Your app bundle can render these; this placeholder exists so routing never crashes.)</p>
        <div class="toolbar">
          <button class="btn btn-ghost" onclick="startTimer(45)">Start 45′ Timer</button>
          <button class="btn btn-ghost" onclick="startTimer(30)">Start 30′ Timer</button>
        </div>
      </section>

      <!-- Corrector (Part 1) view -->
      <section id="view-corrector" class="card" style="display:none;">
        <h3 class="section-title">Corrector (Part 1)</h3>
        <div class="toolbar">
          <label class="pill" title="Uses your Worker (AI); falls back to local rules.">
            <input type="checkbox" id="aiToggle" /> Use AI
          </label>
          <span id="p1InWC" class="pill">Input: 0 words</span>
          <span id="p1OutWC" class="pill">Output: 0 words</span>
        </div>
        <div class="grid grid-2">
          <div class="col">
            <label>Input</label>
            <textarea id="input" placeholder="Paste your text…"></textarea>
          </div>
          <div class="col">
            <label>Output</label>
            <textarea id="output" placeholder="Corrected text will appear here…" readonly></textarea>
          </div>
        </div>
        <div class="toolbar">
          <button class="btn btn-primary" id="btnCorrect">Correct</button>
          <button class="btn btn-ghost" id="btnExportPDF">Export PDF</button>
          <button class="btn btn-ghost" id="btnClear">Clear</button>
          <button class="btn btn-ghost" id="btnPaste">Paste</button>
          <button class="btn btn-ghost" id="btnTimer" onclick="startTimer(45)">Start timer</button>
        </div>
        <div id="preview" class="muted">Preview area…</div>
      </section>

      <!-- Punctuation view -->
      <section id="view-punct" class="card" style="display:none;">
        <h3 class="section-title">Core Punctuation Rules</h3>
        <div id="punctRules" class="muted">Your app bundle can populate the rules. Placeholder present for stability.</div>
      </section>

      <!-- Part 2 view -->
      <section id="view-part2" class="card" style="display:none;">
        <h3 class="section-title">Part 2 – Genre Corrector</h3>

        <!-- Controls -->
        <div class="grid grid-3">
          <div class="col">
            <label for="p2Level">Level</label>
            <select id="p2Level">
              <option value="B2">B2</option>
              <option value="C1" selected>C1</option>
              <option value="C2">C2</option>
            </select>
          </div>
          <div class="col">
            <label for="p2Type">Genre</label>
            <select id="p2Type">
              <option value="essay">Essay</option>
              <option value="letter">Letter</option>
              <option value="proposal">Proposal</option>
              <option value="report">Report</option>
              <option value="review">Review</option>
            </select>
          </div>
          <div class="col">
            <label><input type="checkbox" id="p2Formal" checked> Formal register</label><br>
            <label title="Uses your Worker (AI); falls back to local rules." class="pill" style="display:inline-flex;align-items:center;gap:6px; margin-top:8px;">
              <input type="checkbox" id="p2UseAI"> Use AI
            </label>
          </div>
        </div>

        <!-- Wordcount pills -->
        <div class="toolbar">
          <span id="p2InWC" class="pill">Input: 0 words</span>
          <span id="p2OutWC" class="pill">Output: 0 words</span>
          <span id="p2TargetWC" class="pill">Target …</span>
          <span id="p2Timer" class="pill">Timer: 00:00</span>
          <label class="pill"><input type="checkbox" id="p2CoachNotes" checked> Coach notes</label>
        </div>

        <!-- IO -->
        <div class="grid grid-2">
          <div class="col">
            <label for="p2Input">Input</label>
            <textarea id="p2Input" placeholder="Paste your Part 2 draft…"></textarea>
            <div class="toolbar">
              <button class="btn btn-primary" onclick="runPart2Correction()">Correct Part 2</button>
              <button class="btn btn-ghost" onclick="downloadPart2PDF()">Export PDF</button>
              <button class="btn btn-ghost" onclick="clearPart2()">Clear</button>
              <button class="btn btn-ghost" onclick="pastePart2()">Paste</button>
              <button class="btn btn-ghost" onclick="startTimer(45)">Start timer</button>
            </div>
          </div>
          <div class="col">
            <label for="p2Output">Output</label>
            <textarea id="p2Output" placeholder="Corrected Part 2 will appear here…"></textarea>
          </div>
        </div>

        <!-- Preview + meta -->
        <div class="grid grid-2" style="margin-top:12px;">
          <div class="col">
            <h4 class="section-title">Preview (highlighted)</h4>
            <div id="part2Preview"></div>
            <div id="p2Positions" class="muted" style="margin-top:8px;"></div>
          </div>
          <div class="col">
            <h4 class="section-title">Changes</h4>
            <div id="part2Changes" class="card" style="min-height:120px;">(No changes yet)</div>
            <h4 class="section-title" style="margin-top:12px;">Vocabulary upgrades</h4>
            <div id="part2Vocab" class="card">(Suggestions will appear here)</div>
          </div>
        </div>

        <div class="card" style="margin-top:12px;">
          <h4 class="section-title">Genre rubric</h4>
          <div id="part2Rubric" class="muted">(Rubric checks will appear here)</div>
        </div>
      </section>
    </main>
  </div>

  <!-- Your external bundle (keep this, as in your original) -->
  <script src="/essay-coach-instant/assets/app.bundle.js" defer></script>

  <!-- ===== Core app script you asked me to rewrite (dropped in verbatim) ===== -->
  <script>
"use strict";

/* ========== Small utilities ========== */
const $    = (id) => document.getElementById(id);
const t    = (k) => (window.t?.(k));
const html = (s) => (typeof escapeHtml === "function" ? escapeHtml(String(s)) : String(s));
const wc   = (s) => (String(s||"").match(/\b[\w’'-]+\b/g) || []).length;
const hasAI = () => typeof window.AI_ENDPOINT === "string" && window.AI_ENDPOINT.startsWith("https://");
const inRange = (n, a, b) => n >= a && n <= b;

/* ========== Part 2: wordcount pills ========== */
function updatePart2WordcountPills(){
  const input = ($("#p2Input")?.value || "");
  const output = ($("#p2Output")?.value || "");
  const lvl = $("#p2Level")?.value || "B2";
  const pills = (typeof p2TargetForLevel === "function") ? p2TargetForLevel(lvl) : {min:0, max: 9999, label:""};

  const inWC  = wc(input);
  const outWC = wc(output);

  const inLabel  = (t('io.input_words')  || 'Input: {n} words').replace('{n}', inWC);
  const outLabel = (t('io.output_words') || 'Output: {n} words').replace('{n}', outWC);

  const inEl  = $("#p2InWC");
  const outEl = $("#p2OutWC");
  const tEl   = $("#p2TargetWC");

  if (inEl)  inEl.textContent = inLabel;
  if (outEl) {
    outEl.textContent = outLabel;
    outEl.className = "pill";
    if (outWC > 0 && !inRange(outWC, pills.min, pills.max)) outEl.classList.add("warn");
    if (inRange(outWC, pills.min, pills.max)) outEl.classList.add("ok");
  }
  if (tEl) tEl.textContent = pills.label;
}

// live updates
["p2Input", "p2Output"].forEach(id => {
  document.addEventListener("input", (e) => {
    if (e.target && e.target.id === id) updatePart2WordcountPills();
  });
});

/* ========== Part 2: clause highlighting ========== */
function p2FindConjAdvMatches(text){
  return (typeof findConjAdvMatches === "function") ? findConjAdvMatches(text) : [];
}
function p2FindFanboysMatches(text){
  return (typeof findFanboysMatches === "function") ? findFanboysMatches(text) : [];
}

function p2CoachClauseNotes(corrected, level){
  const enabled = ($("#p2CoachNotes")?.checked !== false);
  if (!enabled || !corrected) return { notes: [], marks: [] };

  const cadv = p2FindConjAdvMatches(corrected);
  const fanb = p2FindFanboysMatches(corrected);
  const notes = [];

  cadv.forEach(({group,label,start,end})=>{
    const L = label?.trim?.() || "";
    if (group === "contrast")  notes.push(`Used “${L}” to join two clauses (C1 style) at chars ${start}–${end}.`);
    else if (group === "result")   notes.push(`Used “${L}” (result) at chars ${start}–${end}.`);
    else if (group === "addition") notes.push(`Used “${L}” (addition) at chars ${start}–${end}.`);
  });
  fanb.forEach(({label,start,end})=>{
    notes.push(`Coordinating join “${label?.trim?.()||""}” at ${start}–${end}.`);
  });

  // de-overlap & assign ids
  let marks = [...cadv, ...fanb].sort((a,b)=>a.start-b.start);
  const filtered = []; let lastEnd = -1, i = 1;
  marks.forEach(m => {
    if (m.start >= lastEnd) { m.id = `p2hl-${i++}`; filtered.push(m); lastEnd = m.end; }
  });
  return { notes, marks: filtered };
}

function p2BuildHighlightedHTML(text, marks){
  const safe = (s) => html(s).replace(/\n/g,"<br>");
  if (!marks.length) return safe(text);
  let out = "", idx = 0;
  for (const m of marks){
    out += safe(text.slice(idx, m.start));
    const inner = safe(text.slice(m.start, m.end));
    const title = html(m.label?.trim?.() || "");
    out += `<mark class="hl" id="${m.id}" title="${title}">${inner}</mark>`;
    idx = m.end;
  }
  out += safe(text.slice(idx));
  return out;
}

function p2RenderPreview(corrected, level){
  const lvl = level || $("#p2Level")?.value || "B2";
  const { notes: coach, marks } = p2CoachClauseNotes(corrected, lvl);

  const prev = $("#part2Preview");
  if (prev) prev.innerHTML = p2BuildHighlightedHTML(corrected, marks);

  const posBox = $("#p2Positions");
  if (posBox){
    if (!marks.length) posBox.innerHTML = "";
    else {
      const chips = marks.map(m=>`<a href="#" onclick="document.getElementById('${m.id}')?.scrollIntoView({behavior:'smooth',block:'center'});return false;">${m.start}–${m.end}</a>`).join(" ");
      posBox.innerHTML = `<b>${t('preview.marked_spans') || 'Marked spans:'}</b> ${chips}`;
    }
  }

  const notesBox = $("#part2Changes");
  if (notesBox && coach.length){
    if (!/Coach notes:/i.test(notesBox.innerHTML)) notesBox.innerHTML += "<br>";
    notesBox.innerHTML += "<br><b>Coach notes:</b><br>" + coach.map(n=>"• "+html(n)).join("<br>");
  }
}

/* ========== Part 2: vocab alternatives ========== */
function renderAlternativesP2(currentText, alts, level){
  const box = $("#part2Vocab");
  if (!box) return;

  if (!alts || !alts.length){
    box.innerHTML = `<span class='hint'>${t('part2.vocab_alts_wait') || 'After correction, suggested upgrades will appear here.'}</span>`;
    return;
  }

  box.innerHTML = "";
  const limitMap = { B2: 4, C1: 6, C2: 8 };

  alts.forEach(({ simple, options })=>{
    const sec = document.createElement("div"); sec.className = "alt-section";
    const h = document.createElement("h4");
    h.textContent = `“${simple}” → ${t('vocab.alternatives_title') || 'Consider alternatives:'}`;
    sec.appendChild(h);

    (options || []).slice(0, limitMap[level] || 4).forEach(opt=>{
      const chip = document.createElement("button");
      chip.className = "chip"; chip.textContent = opt;
      chip.onclick = () => {
        if (typeof wordRe !== "function") return;
        const ta = $("#p2Output");
        const base = ta?.value || currentText || "";
        const re = wordRe(simple);
        const replaced = base.replace(re, m => (m[0] === m[0].toUpperCase() ? opt[0].toUpperCase()+opt.slice(1) : opt));
        if (ta) ta.value = replaced;
        p2RenderPreview(replaced, level);
        updatePart2WordcountPills();
      };
      sec.appendChild(chip);
    });
    box.appendChild(sec);
  });
}

/* ========== Part 2: rubric ========== */
function p2GenreRubric(text, lvl, type){
  const checks = [];
  const count = wc(text);
  const target = (typeof p2TargetForLevel === "function") ? p2TargetForLevel(lvl) : {min:0,max:9999};
  const okWC = inRange(count, target.min, target.max);

  checks.push(okWC
    ? `✅ ${(t('io.output_words') || 'Output: {n} words').replace('{n}', count)}`
    : `⚠️ ${(t('io.output_words') || 'Output: {n} words').replace('{n}', count)}; ${t('part2.target') || 'target'} ${target.min}–${target.max}.`
  );

  if (type === "letter"){
    checks.push(/\bDear\b/.test(text) ? "✅ Salutation present." : "⚠️ Add an appropriate salutation (e.g., “Dear Ms X,”).");
    checks.push(/\bYours (faithfully|sincerely)\b/i.test(text) ? "✅ Formal sign-off present." : "⚠️ Add a formal sign-off (“Yours sincerely/faithfully”).");
    checks.push(/\bI am writing\b|\bI would like to\b/i.test(text) ? "✅ Purpose stated early." : "⚠️ State purpose early (“I am writing to…”).");
  } else if (type === "proposal"){
    const heads = /(Objective|Objectives|Plan|Benefits|Recommendation|Recommendations)/i.test(text);
    checks.push(heads ? "✅ Structural headings detected." : "⚠️ Use clear sections (Objectives, Plan, Benefits, Recommendations).");
    checks.push(/\brecommend(ed|ation|ations)?\b|It is recommended\b/i.test(text) ? "✅ Explicit recommendations." : "⚠️ Add explicit, actionable recommendations.");
  } else if (type === "report"){
    const sections = /(Findings|Analysis|Recommendations)/i.test(text);
    checks.push(sections ? "✅ Findings/Analysis/Recommendations present." : "⚠️ Include Findings → Analysis → Recommendations.");
    checks.push(/\b(It is|There is|There are|was|were)\b/i.test(text) ? "✅ Impersonal register appears." : "⚠️ Prefer an objective/impersonal register.");
  } else if (type === "review"){
    checks.push(/\b(recommend|worth|audience|viewers|readers)\b/i.test(text) ? "✅ Verdict/audience indicated." : "⚠️ End with a clear verdict and audience.");
    checks.push(/\b(style|pacing|voice|theme|motif|character)\b/i.test(text) ? "✅ Evaluation of craft/themes." : "⚠️ Evaluate craft/themes, not only plot.");
  }
  return checks.join("<br>");
}

function p2RenderRubric(text, lvl, type){
  const box = $("#part2Rubric");
  if (box) box.innerHTML = p2GenreRubric(String(text||""), lvl, type);
}

/* ========== Part 2: main corrector ========== */
async function runPart2Correction(){
  const input  = $("#p2Input")?.value.trim() || "";
  const lvl    = $("#p2Level")?.value || "B2";
  const type   = $("#p2Type")?.value || "essay";
  const formal = !!$("#p2Formal")?.checked;
  const useAI  = !!$("#p2UseAI")?.checked && hasAI();

  const outBox   = $("#p2Output");
  const changes  = $("#part2Changes");
  const vocabBox = $("#part2Vocab");

  if (!input){
    if (outBox) outBox.value = "";
    if (changes) changes.innerHTML = "<b>" + (t('preview.changes_title') || 'Changes:') + "</b><br><span class='hint'>" + (t('warn.no_text') || 'Paste your text to get started.') + "</span>";
    if (vocabBox) vocabBox.innerHTML = "<span class='hint'>" + (t('part2.vocab_alts_wait') || 'After correction, suggested upgrades will appear here.') + "</span>";
    const prev = $("#part2Preview"); if (prev) prev.innerHTML = "";
    const pos  = $("#p2Positions");  if (pos)  pos.innerHTML = "";
    updatePart2WordcountPills();
    return;
  }

  if (changes) changes.innerHTML = "<b>" + (t('preview.changes_title') || 'Changes:') + "</b><br><span class='hint'>Processing…</span>";
  if (vocabBox) vocabBox.innerHTML = "<span class='hint'>Processing…</span>";
  if (outBox) outBox.value = "";
  const prev = $("#part2Preview"); if (prev) prev.innerHTML = "";
  const pos  = $("#p2Positions");  if (pos)  pos.innerHTML  = "";

  // AI path
  if (useAI){
    try{
      const res = await fetch(window.AI_ENDPOINT, {
        method: "POST",
        headers: { "Content-Type":"application/json" },
        body: JSON.stringify({ text: input, level: lvl, formal, style: (typeof p2StyleFor === "function" ? p2StyleFor(lvl, type) : undefined), genre: type })
      });
      const raw = await res.text();
      if (!res.ok){
        if (changes) changes.innerHTML = `<b>AI call failed:</b> HTTP ${res.status}<br><pre style="white-space:pre-wrap">${html(raw)}</pre><br><i>Using local rules instead.</i>`;
        throw new Error("AI HTTP " + res.status);
      }

      let data;
      try { data = JSON.parse(raw); }
      catch {
        if (changes) changes.innerHTML = `<b>AI returned non-JSON:</b><br><pre style="white-space:pre-wrap">${html(raw)}</pre><br><i>Using local rules instead.</i>`;
        throw new Error("AI non-JSON");
      }

      if (data && typeof data.corrected === "string"){
        const aiOut = data.corrected;
        if (typeof _aiMadeNoChanges === "function" && _aiMadeNoChanges(input, aiOut)){
          // fallback to local if AI made no edits
          const { out, notes, alts } = (typeof correctLocal === "function") ? correctLocal(input, lvl) : { out: input, notes: [], alts: [] };
          if (outBox) outBox.value = out;
          if (changes) changes.innerHTML = "<b>" + (t('preview.changes_title') || 'Changes:') + " (local fallback – AI made no edits)</b><br>" +
            (notes.length ? notes.map(n=>"• "+html(n)).join("<br>") : "(" + (t('vocab.alternatives_wait')||'No major changes') + ")");
          const fromAI   = (data.alternatives && typeof data.alternatives === "object") ? data.alternatives : {};
          const fromLocal= (typeof buildAlternatives === "function") ? buildAlternatives(out, lvl) : {};
          const merged   = (typeof mergeAlternatives === "function") ? mergeAlternatives(fromAI, fromLocal) : (fromLocal || []);
          renderAlternativesP2(out, merged, lvl);
          p2RenderPreview(out, lvl);
          p2RenderRubric(out, lvl, type);
          updatePart2WordcountPills();
          return;
        }

        if (outBox) outBox.value = aiOut;
        const baseNotes = Array.isArray(data.notes) ? data.notes : [];
        if (changes) changes.innerHTML = "<b>" + (t('preview.changes_title') || 'Changes:') + " (AI)</b><br>" +
          (baseNotes.length ? baseNotes.map(n=>"• "+html(n)).join("<br>") : "(" + (t('vocab.alternatives_wait')||'none') + ")");

        if (Array.isArray(data.replacements) && data.replacements.length){
          changes.innerHTML += "<br><b>Upgrades:</b><br>";
          data.replacements.forEach(r=>{
            changes.innerHTML += "• Replaced “"+html(r.from)+"” → “"+html(r.to)+"”<br>";
          });
        } else if (typeof detectIntensifierNotes === "function"){
          const extra = detectIntensifierNotes(input, aiOut);
          if (extra.length) changes.innerHTML += "<br>" + extra.map(n => "• " + html(n)).join("<br>");
        }

        const fromAI    = (data.alternatives && typeof data.alternatives === "object") ? data.alternatives : {};
        const fromLocal = (typeof buildAlternatives === "function") ? buildAlternatives(aiOut, lvl) : {};
        const merged    = (typeof mergeAlternatives === "function") ? mergeAlternatives(fromAI, fromLocal) : (fromLocal || []);
        renderAlternativesP2(aiOut, merged, lvl);
        p2RenderPreview(aiOut, lvl);
        p2RenderRubric(aiOut, lvl, type);
        updatePart2WordcountPills();
        return;
      } else {
        if (changes) changes.innerHTML = `<b>AI response missing "corrected".</b><br><pre style="white-space:pre-wrap">${html(raw)}</pre><br><i>Using local rules instead.</i>`;
        throw new Error('AI missing corrected');
      }
    } catch(e){
      // fall through to local
    }
  }

  // Local path
  try{
    const { out, notes, alts } = (typeof correctLocal === "function") ? correctLocal(input, lvl) : { out: input, notes: [], alts: [] };
    if (outBox) outBox.value = out;
    const title = t('preview.changes_title') || 'Changes:';
    const body  = (notes.length ? notes.map(n=>"• "+html(n)).join("<br>") : "(" + (t('vocab.alternatives_wait')||'No major changes') + ")");
    if (changes) changes.innerHTML = "<b>"+title+" (local)</b><br>"+body;
    renderAlternativesP2(out, alts, lvl);
    p2RenderPreview(out, lvl);
    p2RenderRubric(out, lvl, type);
    updatePart2WordcountPills();
  } catch(e){
    if (changes) changes.innerHTML = `<b>Local corrector failed:</b> ${html(e.message)}`;
    if (outBox) outBox.value = input;
    updatePart2WordcountPills();
  }
}

/* ========== Part 2: helpers ========== */
function clearPart2(){
  const prev = $("#part2Preview");
  const pos  = $("#p2Positions");
  const ch   = $("#part2Changes");
  const vb   = $("#part2Vocab");
  const out  = $("#p2Output"); if (out) out.value = "";
  const inp  = $("#p2Input");  if (inp) inp.value = "";
  if (prev) prev.innerHTML = "";
  if (pos)  pos.innerHTML  = "";
  if (ch)   ch.innerHTML   = "<b>"+(t('preview.changes_title')||'Changes:')+"</b><br><span class='hint'>"+(t('btn.clear')||'Cleared')+".</span>";
  if (vb)   vb.innerHTML   = (t('part2.vocab_alts_wait') || 'After correction, suggested upgrades will appear here.');
  updatePart2WordcountPills();
}

async function pastePart2(){
  const ta = $("#p2Input"); if (!ta) return;
  try{
    const text = await navigator.clipboard.readText();
    if (text){
      const start = ta.selectionStart ?? ta.value.length;
      const end   = ta.selectionEnd   ?? ta.value.length;
      ta.value = ta.value.slice(0,start) + text + ta.value.slice(end);
      ta.focus(); ta.selectionStart = ta.selectionEnd = start + text.length;
      updatePart2WordcountPills();
    } else alert(t('warn.no_text') || "Your clipboard is empty.");
  } catch(e){
    alert(t('errors.clipboard_blocked') || "Browser blocked clipboard. Try Ctrl/Cmd+V or long-press → Paste.");
  }
}

function downloadPart2PDF(){
  try{
    const { jsPDF } = window.jspdf || {};
    if (!jsPDF){ alert(t('errors.pdf_lib_failed') || "PDF library failed to load."); return; }
    const doc = new jsPDF({ unit:"pt", format:"a4" });
    const margin = 48; let y = margin;
    doc.setFont("Helvetica","bold"); doc.setFontSize(14);
    doc.text((t('export.title') || "Correction report") + " – Part 2", margin, y); y += 20;
    doc.setFont("Helvetica","normal"); doc.setFontSize(12);
    const text = $("#p2Output")?.value || "(" + (t('warn.no_text') || 'empty') + ")";
    const lines = doc.splitTextToSize(text, 595 - margin*2);
    doc.text(lines, margin, y);
    doc.save("part2-corrected.pdf");
  } catch(e){
    alert((t('errors.pdf_failed') || "Could not create PDF: ") + e.message);
  }
}

/* ========== Shared timer (i18n) ========== */
let _timer = null, _until = 0;
function startTimer(minutes = 45){
  _until = Date.now() + minutes*60*1000;
  if (_timer) clearInterval(_timer);
  const paint = () => {
    const left = Math.max(0, _until - Date.now());
    const m = String(Math.floor(left/60000)).padStart(2,'0');
    const s = String(Math.floor((left%60000)/1000)).padStart(2,'0');
    const label = (t('io.timer_label') || 'Timer: {m}:{s}').replace('{m}', m).replace('{s}', s);
    const main = $("#timer");   if (main) main.textContent = label;
    const p2t  = $("#p2Timer"); if (p2t)  p2t.textContent  = label;
    if (left <= 0) { clearInterval(_timer); _timer = null; }
  };
  paint(); _timer = setInterval(paint, 500);
}

/* ========== Boot ========== */
try { typeof renderScaffold   === "function" && renderScaffold(); } catch {}
try { typeof renderPunctRules === "function" && renderPunctRules(); } catch {}

window.addEventListener("load", () => {
  // AI toggles
  const setAIToggle = (el) => {
    if (!el) return;
    const on = hasAI();
    el.checked = on; el.disabled = !on;
    if (!el.title) el.title = on
      ? (t('hint.ai_enabled') || "Uses your Worker (AI); falls back to local rules.")
      : (t('hint.ai_disabled') || "Set window.AI_ENDPOINT to enable AI corrections.");
  };
  setAIToggle($("#aiToggle"));
  setAIToggle($("#p2UseAI"));

  // Hash routing
  try {
    if (location.hash === "#corrector")      showTab?.("corrector");
    else if (location.hash === "#punct")     showTab?.("punct");
    else if (location.hash === "#part2")     showPart2?.();
    else                                     showTab?.("scaffolds");
  } catch {}

  // Wordcount pills (both parts)
  try { typeof updateWordPills === "function" && updateWordPills(); } catch {}
  try { updatePart2WordcountPills(); } catch {}
});

// Failsafe tab wiring
(function () {
  const tSc = $("#tab-scaffolds");
  const tCo = $("#tab-corrector");
  const tPu = $("#tab-punct");
  const tP2 = $("#tab-part2");

  function safeShow(w) {
    try { if (w === "part2") showPart2?.(); else showTab?.(w); }
    catch {
      const vs = $("#view-scaffolds");
      const vc = $("#view-corrector");
      const vp = $("#view-punct");
      const v2 = $("#view-part2");
      if (vs && vc && vp && v2){
        vs.style.display = (w==='scaffolds') ? "" : "none";
        vc.style.display = (w==='corrector') ? "" : "none";
        vp.style.display = (w==='punct')     ? "" : "none";
        v2.style.display = (w==='part2')     ? "" : "none";
      }
    }
  }
  tSc?.addEventListener("click", () => safeShow("scaffolds"));
  tCo?.addEventListener("click", () => safeShow("corrector"));
  tPu?.addEventListener("click", () => safeShow("punct"));
  tP2?.addEventListener("click", () => safeShow("part2"));
})();
</script>


  <!-- Optional: jsPDF for PDF export (if not provided elsewhere) -->
  <script src="https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js" defer></script>
</body>
</html>

