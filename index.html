<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>EssayCoach – Cambridge Toolkit (PWA)</title>

  <!-- Icons -->
  <link rel="icon" type="image/png" sizes="192x192" href="icon-192.png" />
  <link rel="apple-touch-icon" href="icon-192.png" />

  <!-- PWA -->
  <link rel="manifest" href="manifest.webmanifest" />
  <meta name="theme-color" content="#111111" />

  <style>
    :root { --b:#111; --bg:#f6f7fb; --card:#fff; --muted:#6b7280; --border:#e5e7eb; }
    * { box-sizing: border-box; }
    body { font-family: system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif; margin:0; background:var(--bg); color:#111; }
    .wrap { max-width: 980px; margin: 0 auto; padding: clamp(16px, 4vw, 24px); }
    h1 { margin: 0 0 6px; font-size: clamp(22px, 3.6vw, 28px); }
    .sub { color: var(--muted); margin: 0 0 16px; font-size: clamp(13px, 2.8vw, 14px); }

    .tabs { display:flex; gap:8px; flex-wrap:wrap; margin-bottom:12px; }
    .tab { padding:12px 14px; border:1px solid var(--border); border-radius:12px; background:#fff; cursor:pointer; font-size:14px; min-height:44px; }
    .tab.active { background: var(--b); color:#fff; border-color: var(--b); }

    .card { background: var(--card); border:1px solid var(--border); border-radius:14px; padding: clamp(12px, 3.2vw, 16px); }
    .row { display:flex; gap:8px; flex-wrap:wrap; }
    .cols { display:grid; grid-template-columns: 1fr 1fr; gap:12px; }
    @media (max-width: 860px) { .cols { grid-template-columns: 1fr; } }

    textarea, select, button { font:inherit; padding:12px 14px; border:1px solid var(--border); border-radius:12px; background:#fff; min-height:44px; }
    textarea { width:100%; resize:vertical; -webkit-user-select:text; user-select:text; -webkit-touch-callout:default; }
    button { cursor:pointer; }
    button.primary { background: var(--b); color:#fff; border-color: var(--b); }

    .notes { margin-top:10px; background:#f3f4f6; padding:10px; border-radius:10px; border:1px solid var(--border); }
    .hint { color:var(--muted); font-size:12px; margin-top:6px; }
    ul, ol { margin-top:6px; padding-left:20px; }

    .chip { display:inline-block; padding:8px 12px; border:1px solid var(--border); border-radius:999px; background:#fff; margin:6px 8px 0 0; cursor:pointer; font-size:14px; min-height:38px; }
    .chip:hover { background:#f3f4f6; }
    .alt-section h4 { margin:12px 0 6px; font-size:14px; color:#333; }

    .toggle { display:flex; align-items:center; gap:8px; margin-top:6px; font-size:14px; }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>EssayCoach – Cambridge Toolkit</h1>
    <p class="sub">Scaffolds • Corrector (B2/C1) • Formal tone • Safer spelling + a/an • Clause punctuation • Alternatives • PDF • PWA</p>

    <!-- Tabs -->
    <div class="tabs">
      <button class="tab active" id="tab-scaffolds" onclick="showTab('scaffolds')">Scaffolds</button>
      <button class="tab" id="tab-corrector" onclick="showTab('corrector')">Corrector</button>
    </div>

    <!-- SCAFFOLDS TAB -->
    <section id="view-scaffolds">
      <div class="card" style="margin-bottom:12px">
        <div class="cols">
          <label>
            <div style="color:#6b7280; font-size:14px; margin-bottom:6px">Level</div>
            <select id="scLevel" onchange="renderScaffold()">
              <option value="B2">B2 First</option>
              <option value="C1">C1 Advanced</option>
            </select>
          </label>

          <label>
            <div style="color:#6b7280; font-size:14px; margin-bottom:6px">Task type</div>
            <select id="scType" onchange="renderScaffold()">
              <option value="essay">Essay</option>
              <option value="report">Report</option>
              <option value="review">Review</option>
              <option value="letter">Formal letter/email</option>
            </select>
          </label>
        </div>

        <div class="row" style="margin-top:12px">
          <button onclick="copyScaffold()">Copy scaffold</button>
          <button onclick="copyOpener()">Copy opener</button>
          <button onclick="exportScaffoldPDF()">Export scaffold as PDF</button>
        </div>
      </div>

      <div class="card">
        <h3 style="margin:0">Recommended moves (4-part structure)</h3>
        <ol id="scMoves"></ol>

        <h3 style="margin:16px 0 6px">Useful opener (example)</h3>
        <div id="scOpener" class="notes"></div>

        <h3 style="margin:16px 0 6px">Tips</h3>
        <ul id="scTips"></ul>
        <div class="hint">Choose level and task to update the scaffold. You can copy or export to PDF.</div>
      </div>
    </section>

    <!-- CORRECTOR TAB -->
    <section id="view-corrector" style="display:none">
      <div class="card" style="margin-bottom:12px">
        <label style="display:block; margin-bottom:8px">
          <div style="color:#6b7280; font-size:14px; margin-bottom:6px">Level</div>
          <select id="levelSelect">
            <option value="B2">B2 First</option>
            <option value="C1">C1/C2 Advanced</option>
          </select>
        </label>

        <label style="display:block; margin-top:10px">
          <div style="color:#6b7280; font-size:14px; margin-bottom:6px">Input</div>
          <textarea id="inputText" rows="7" placeholder="Type or paste your text here..."></textarea>
        </label>

        <div class="row" style="margin-top:10px">
          <button class="primary" onclick="runCorrection()">Correct</button>
          <button onclick="downloadPDF()">Export PDF</button>
          <button onclick="clearAll()">Clear</button>
          <button onclick="pasteFromClipboard()">Paste</button>
        </div>

        <label class="toggle">
          <input type="checkbox" id="formalToggle" checked />
          <span>Enforce formal tone (avoid slang/colloquialisms)</span>
        </label>

        <label class="toggle">
          <input type="checkbox" id="aiToggle" />
          <span>Use AI (ChatGPT) for deeper corrections (requires Worker URL)</span>
        </label>

        <div class="hint" style="margin-top:6px">
          Try: “It was late however we continued the discussion” → “It was late; however, we continued the discussion.”
          • “First I would like to…” → “First, I would like to…”
          • “a apple” → “an apple” • “whot” → “what”
        </div>
      </div>

      <div class="card" style="margin-bottom:12px">
        <div style="color:#6b7280; font-size:14px; margin-bottom:6px">Corrected Output</div>
        <textarea id="outputText" rows="7" readonly placeholder="Your corrected text will appear here..."></textarea>
        <div class="notes" id="notes"><b>Changes:</b><br><span class="hint">Corrections will appear here after you click “Correct”.</span></div>
      </div>

      <div class="card">
        <h3 style="margin:0 0 6px">Vocabulary alternatives (click to apply)</h3>
        <div id="altList" class="hint">After correction, suggested upgrades will appear here (especially for C1/C2).</div>
      </div>
    </section>
  </div>

  <!-- jsPDF -->
  <script src="https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js" crossorigin="anonymous"></script>

  <!-- Main logic -->
  <script>
    /* ========= Cloudflare Worker AI endpoint ========= */
    const AI_ENDPOINT = "https://essaycoach.alfons149.workers.dev"; // your Worker URL

    /* ========= Tabs ========= */
    function showTab(which){
      document.getElementById('tab-scaffolds').classList.toggle('active', which==='scaffolds');
      document.getElementById('tab-corrector').classList.toggle('active', which==='corrector');
      document.getElementById('view-scaffolds').style.display  = (which==='scaffolds') ? '' : 'none';
      document.getElementById('view-corrector').style.display  = (which==='corrector') ? '' : 'none';
    }
    <script>
  // Failsafe: wire up clicks even if inline onclicks were stripped or a prior error happened
  (function(){
    const a=document.getElementById('tab-scaffolds');
    const b=document.getElementById('tab-corrector');
    const safeShow = (w)=>{ try { showTab(w); } catch(e) { 
      // brute-force show/hide if showTab is broken
      const vs=document.getElementById('view-scaffolds');
      const vc=document.getElementById('view-corrector');
      if (w==='scaffolds'){ vs.style.display=''; vc.style.display='none'; }
      else { vc.style.display=''; vs.style.display='none'; }
    }};
    a?.addEventListener('click', ()=>safeShow('scaffolds'));
    b?.addEventListener('click', ()=>safeShow('corrector'));
  })();
</script>


    /* ========= Scaffolds (B2 / C1) ========= */
    const SCAFFOLDS = {
      B2: {
        essay: { moves: [
          "Introduction: Paraphrase the question; give a clear opinion.",
          "Body 1: First main point + short example/evidence.",
          "Body 2: Second main point + short example/evidence.",
          "Conclusion: Summarise and restate your opinion."
        ],
        opener: "In recent years, the question of [topic] has received considerable attention. In my view, [your opinion], because [reason].",
        tips: [
          "Use clear topic sentences at the start of each paragraph.",
          "Avoid contractions and slang; use formal linkers (however, in addition, therefore).",
          "Keep sentences concise; prefer clarity over complexity."
        ]},
        report: { moves:[
          "Introduction: Purpose and who the report is for.",
          "Findings 1: Current situation/results.",
          "Findings 2: Problems/positives.",
          "Recommendations: Specific, practical suggestions."
        ],
        opener:"The aim of this report is to evaluate [place/system] and to suggest improvements based on recent feedback.",
        tips:["Use headings and bullet points if allowed.","Be objective and concise; avoid personal anecdotes.","Use formal register: 'It is recommended that…'"]},
        review: { moves:[
          "Intro: Title/creator/genre + overall verdict.",
          "Paragraph 1: Brief summary (no spoilers).",
          "Paragraph 2: Evaluation (strengths/weaknesses).",
          "Conclusion: Who would enjoy it + rating."
        ],
        opener:"[Title] is a [genre] that succeeds because of its [feature], offering a [tone] experience for the audience.",
        tips:["Balance description and evaluation.","Use precise adjectives and avoid repetition.","End with a clear recommendation."]},
        letter: { moves:[
          "Greeting (Dear Sir/Madam / Dear Ms X).",
          "Opening: Reason for writing.",
          "Body: Key points in logical order.",
          "Closing: Action/request + formal sign-off."
        ],
        opener:"Dear Sir or Madam, I am writing to enquire about [topic], particularly regarding [specific detail].",
        tips:["Match tone to the reader; use formal phrases.","Close with: 'I look forward to your response.'","Sign off: 'Yours faithfully' / 'Yours sincerely'."]}
      },
      C1: {
        essay: { moves:[
          "Introduction: Contextualise the issue; define the scope.",
          "Body 1: Develop first argument with analysis and support.",
          "Body 2: Counter-argument or complementary argument with synthesis.",
          "Conclusion: Weigh points; deliver a nuanced final stance."
        ],
        opener:"While opinions differ regarding [topic], this essay argues that [your position] because [reason(s)], provided that [qualifier if needed].",
        tips:["Use a wide range of cohesive devices (nevertheless, consequently).","Develop ideas with cause–effect and exemplification.","Maintain precise register; avoid vague verbs."]},
        report: { moves:[
          "Purpose & methods (who/what/when).",
          "Findings (data + patterns).",
          "Analysis (implications/causes).",
          "Recommendations (prioritised, actionable)."
        ],
        opener:"This report assesses [programme/process] using [method], highlighting key outcomes and areas requiring action.",
        tips:["Use data where possible (percentages, trends).","Prioritise recommendations and justify them.","Avoid first-person unless specified."]},
        review: { moves:[
          "Hook + brief context.",
          "Overview (no spoilers) + craft elements (style, pacing, voice).",
          "Evaluation (themes, impact) with examples.",
          "Verdict (audience + comparative judgement)."
        ],
        opener:"Combining [quality] with [quality], [Title] interrogates [theme] and ultimately delivers a compelling [genre] experience.",
        tips:["Vary sentence structure for rhythm and emphasis.","Use precise terminology (narrator, motif, register).","Compare/contrast with similar works for depth."]},
        letter: { moves:[
          "Appropriate salutation + clear purpose.",
          "Developed points with well-sequenced paragraphs.",
          "Tone/register control for the reader and purpose.",
          "Close with a firm next step and formal sign-off."
        ],
        opener:"Dear [Title + Surname], I am writing in connection with [topic], and I would appreciate clarification on [specific details].",
        tips:["Maintain formal register throughout.","Employ hedging where appropriate (I would suggest / It appears that…).","End with a clear call to action."]}
      }
    };

    function renderScaffold(){
      const lvl = document.getElementById('scLevel').value;
      const typ = document.getElementById('scType').value;
      const d = SCAFFOLDS[lvl][typ];
      document.getElementById('scMoves').innerHTML = d.moves.map(m => `<li>${escapeHtml(m)}</li>`).join('');
      document.getElementById('scOpener').textContent = d.opener;
      document.getElementById('scTips').innerHTML = d.tips.map(t => `<li>${escapeHtml(t)}</li>`).join('');
    }
    function copyScaffold(){
      const lvl=scLevel.value, typ=scType.value, d=SCAFFOLDS[lvl][typ];
      const txt=`Scaffold (${lvl} ${typ})
1) ${d.moves[0]}
2) ${d.moves[1]}
3) ${d.moves[2]}
4) ${d.moves[3]}`;
      navigator.clipboard?.writeText(txt); alert("Scaffold copied.");
    }
    function copyOpener(){ const lvl=scLevel.value, typ=scType.value; navigator.clipboard?.writeText(SCAFFOLDS[lvl][typ].opener); alert("Opener copied."); }

    function exportScaffoldPDF(){
      const { jsPDF } = window.jspdf || {}; if (!jsPDF){ alert("PDF library failed to load."); return; }
      const doc = new jsPDF({ unit:"pt", format:"a4" }), margin=48; let y=margin;
      const lvl=scLevel.value, typ=scType.value, d=SCAFFOLDS[lvl][typ];
      doc.setFont("Helvetica","bold"); doc.setFontSize(16); doc.text(`Cambridge Scaffold – ${lvl} ${typ}`, margin, y); y+=18;
      doc.setFont("Helvetica","normal"); doc.setFontSize(12); doc.text("Recommended moves:", margin, y); y+=14;
      d.moves.forEach((m,i)=>{ const lines=doc.splitTextToSize(`${i+1}) ${m}`, 595-margin*2); doc.text(lines, margin, y); y += 14 + (lines.length-1)*12; });
      y+=6; doc.setFont("Helvetica","bold"); doc.text("Opener:", margin, y); y+=14; doc.setFont("Helvetica","normal");
      doc.text(doc.splitTextToSize(d.opener, 595-margin*2), margin, y); y+=28;
      doc.setFont("Helvetica","bold"); doc.text("Tips:", margin, y); y+=14; doc.setFont("Helvetica","normal");
      d.tips.forEach((t)=>{ const lines=doc.splitTextToSize("• "+t, 595-margin*2); doc.text(lines, margin, y); y += 14 + (lines.length-1)*12; });
      doc.save(`scaffold-${lvl}-${typ}.pdf`);
    }

    /* ========= Utilities ========= */
    const escapeHtml = (s) => String(s).replace(/[&<>"']/g, (m)=>({ "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#039;" }[m]));
    const hasFiniteVerb = (s) => /\b(am|is|are|was|were|be|been|being|do|does|did|has|have|had|can|could|will|would|shall|should|may|might|must)\b/i.test(s) || /\b\w+(ed|s)\b/i.test(s);
    const normalizeText = (s) => String(s).replace(/[\u2018\u2019\u2032]/g,"'").replace(/[\u201C\u201D\u2033]/g,'"').replace(/\u00A0/g," ");

    function fixAAn(text){
      const silentH=/^(honest|honour|honor|hour|heir|herb)\b/i;
      const youSound=/^(uni(vers|form|que|on)|u[bcdfgklmnprstvy]|euro|eure|euph|eulog|ukulele|user|use|one|once|ufo)\b/i;
      const acronym=/^[AEFHILMNORSX]/;
      return text.replace(/\b([Aa]n?)\s+([A-Za-z][\w-]*)/g,(m,art,word)=>{
        const wl=word.toLowerCase(); let shouldBeAn=/^[aeiou]/.test(wl)||silentH.test(wl);
        if (/^[A-Z]{2,}$/.test(word)) shouldBeAn = acronym.test(word[0]);
        if (youSound.test(wl)) shouldBeAn=false;
        const desired = shouldBeAn ? (art[0]==='A'?'An':'an') : (art[0]==='A'?'A':'a');
        if ((art.toLowerCase()==='an')!==shouldBeAn) return desired+" "+word; return m;
      });
    }

    function formalize(text, notes){
      let out=text;
      const rules=[
        { re:/\bkids\b/gi, rep:"children", note:"Replaced informal 'kids'." },
        { re:/\bwanna\b/gi, rep:"want to", note:"Expanded 'wanna'." },
        { re:/\bgonna\b/gi, rep:"going to", note:"Expanded 'gonna'." },
        { re:/\bokay\b|\bOK\b/gi, rep:"acceptable", note:"Formalised 'OK/okay'." },
        { re:/\ba lot of\b/gi, rep:"many", note:"Replaced 'a lot of' with 'many'." }
      ];
      for (const r of rules){ if (r.re.test(out)){ out=out.replace(r.re,r.rep); notes.push(r.note); } }
      return out;
    }

    /* ========= Alternatives ========= */
    const ALT_MAP = {
      base: {
        "good":["effective","beneficial","favourable","advantageous"],
        "bad":["detrimental","problematic","adverse","unsatisfactory"],
        "very":["particularly","highly","notably"],
        "really":["truly","genuinely"],
        "help":["assist","support","enable","facilitate"],
        "use":["utilise","employ","apply"],
        "say":["state","argue","contend","maintain"],
        "thing":["aspect","element","factor","component"]
      },
      c1: {
        "important":["crucial","vital","essential","pivotal"],
        "because":["since","as","given that"],
        "so":["therefore","thus","consequently"],
        "many":["numerous","a multitude of"]
      }
    };
    const wordRe = (w)=>new RegExp(`\\b${w.replace(/[.*+?^${}()|[\\]\\\\]/g,'\\\\$&')}\\b`,'gi');
    function buildAlternatives(text, level){
      const dicts=[ALT_MAP.base, ...(level==='C1'?[ALT_MAP.c1]:[])];
      const out=[];
      dicts.forEach(d=>Object.entries(d).forEach(([k,arr])=>{
        if (wordRe(k).test(text)) out.push({ simple:k, options:arr });
      }));
      return out;
    }
    function renderAlternatives(currentText, alts, level){
      const box=document.getElementById("altList");
      if(!alts.length){ box.innerHTML="<span class='hint'>No suggestions for this text.</span>"; return; }
      box.innerHTML="";
      alts.forEach(({simple,options})=>{
        const sec=document.createElement('div'); sec.className='alt-section';
        const h=document.createElement('h4'); h.textContent=`“${simple}” → consider:`; sec.appendChild(h);
        options.slice(0, level==='C1'?6:4).forEach(opt=>{
          const chip=document.createElement('button'); chip.className='chip'; chip.textContent=opt;
          chip.onclick=()=>{
            const re=wordRe(simple);
            const replaced=(document.getElementById("outputText").value||currentText).replace(re,(m)=>{
              const cap=m[0]===m[0].toUpperCase(); return cap?opt[0].toUpperCase()+opt.slice(1):opt;
            });
            document.getElementById("outputText").value=replaced;
          };
          sec.appendChild(chip);
        });
        box.appendChild(sec);
      });
    }

    /* ========= Local rules corrector (robust fallback) ========= */
    const INTRO_SINGLE = ["First","Firstly","Second","Secondly","Third","Finally","Next","Then","Afterwards","Overall","Currently","Recently","Ultimately","Consequently","Therefore","However","Moreover","Furthermore","Nevertheless","Meanwhile","Instead","Still"];
    const INTRO_PHRASES = ["In addition","In conclusion","In contrast","By contrast","For example","For instance","To begin with","In my opinion","On the one hand","On the other hand","As a result","In other words","In summary","On balance","At first","In general"];
    const FANBOYS = ["for","and","nor","but","or","yet","so"];
    const SUBORD  = ["although","though","because","since","when","while","if","unless","after","before","once","whereas","as"];
    const CADV    = ["however","therefore","moreover","nevertheless","consequently","furthermore","nonetheless","accordingly","thus","otherwise","meanwhile","instead","still"];

    function correctLocal(text, lvl){
      if(!text || !text.trim()) return { out:"", notes:[], alts:[] };
      let out = normalizeText(text.trim());
      const notes=[];

      // contractions → formal
      const CONTR = { "can't":"cannot","won't":"will not","don't":"do not","doesn't":"does not","didn't":"did not","it's":"it is","I'm":"I am","you're":"you are","we're":"we are","they're":"they are","I've":"I have","we've":"we have","they've":"they have" };
      for (const [k,v] of Object.entries(CONTR)){
        const re=new RegExp(`\\b${k.replace(/[-/\\^$*+?.()|[\\]{}]/g,"\\$&")}\\b`,"gi");
        const before=out; out=out.replace(re,(m)=>m[0]===m[0].toUpperCase()?v[0].toUpperCase()+v.slice(1):v);
        if (out!==before) notes.push("Expanded contractions for formality.");
      }

      // spacing normalisation
      const bs=out; out=out.replace(/\s+([,;:.!?])/g,"$1").replace(/([,;:.!?])(\S)/g,"$1 $2").replace(/\s{2,}/g," ");
      if(out!==bs) notes.push("Normalised spacing.");

      // TV capitalisation
      const btv=out; out=out.replace(/\btv\b/g,"TV"); if(out!==btv) notes.push("Capitalised 'TV'.");

      // a/an
      const baa=out; out=fixAAn(out); if(out!==baa) notes.push("Fixed 'a/an'.");

      // formal tone (light)
      const bf=out; out=formalize(out, notes); if(out!==bf){/* noted */ }

      // Introductory commas
      const punctIntro = (t)=>t.replace(/([^.!?]+)([.!?]|$)/g,(m,core,end)=>{
        let s=core.trim();
        for(const ph of INTRO_PHRASES){ const re=new RegExp(`^(${ph})\\s+(?!,)`,"i"); if(re.test(s)) s=s.replace(re,`$1, `); }
        const fw=(s.match(/^(\w+)\s+(?!,)/)||[null,null])[1];
        if(fw && INTRO_SINGLE.includes(fw)) s=s.replace(/^(\w+)\s+(?!,)/,`$1, `);
        return s+(end||"");
      });
      const bi=out; out=punctIntro(out); if(out!==bi) notes.push("Added comma after introductory phrase.");

      // Clause punctuation
      const punctClauses=(t)=>t.replace(/([^.!?]+)([.!?]|$)/g,(m,core,end)=>{
        let s=core.trim();
        // Conjunctive adverb: ; however,
        for(const adv of CADV){
          const re=new RegExp(`\\b${adv}\\b`,"i"); const hit=s.match(re);
          if(hit){ const idx=hit.index, w=hit[0]; const L=s.slice(0,idx).replace(/[ ,;]+$/,"").trim(), R=s.slice(idx+w.length).replace(/^[ ,;]+/,"").trim();
            if (hasFiniteVerb(L) && hasFiniteVerb(R)){ s=`${L}; ${w}, ${R}`; break; }
          }
        }
        // Fronted subordinator → comma
        const first=(s.match(/^\w+/)||[""])[0].toLowerCase();
        if(SUBORD.includes(first) && !/,/.test(s)){ const tokens=s.split(/\s+/);
          const starters=["i","you","he","she","we","they","it","the","a","an","this","that","these","those","many","most","some"];
          let ins=-1; for(let i=3;i<Math.min(tokens.length,20);i++){ if(starters.includes(tokens[i]?.toLowerCase())){ ins=i; break; } }
          if(ins>-1){ tokens.splice(ins,0,","); s=tokens.join(" "); }
        }
        // FANBOYS comma between independent clauses
        for(const cj of FANBOYS){
          const pos=s.toLowerCase().indexOf(` ${cj} `); if(pos>-1 && !new RegExp(`,\\s+${cj}\\b`,"i").test(s)){
            const L=s.slice(0,pos).trim(), R=s.slice(pos+cj.length+2).trim();
            if(hasFiniteVerb(L) && hasFiniteVerb(R)){ s = L.replace(/\s+$/,"") + ", " + cj + " " + R.replace(/^,?\s*/,""); }
          }
        }
        return s+(end||"");
      });
      const bc=out; out=punctClauses(out); if(out!==bc) notes.push("Inserted clause punctuation.");

      // Final full stop
      if(!/[.!?]$/.test(out)){ out+="."; notes.push("Added final full stop."); }

      // Alternatives list
      const alts=buildAlternatives(out, lvl==='C1'?'C1':'B2');
      return { out:out.trim(), notes, alts };
    }
            
  <script>
  // Merge AI alternatives (object) with locally-built (array of {simple, options})
  function mergeAlternatives(aiAltObj, localArr) {
    const outMap = new Map();

    // 1) From AI (object: { "word": ["opt1","opt2",...] })
    if (aiAltObj && typeof aiAltObj === 'object') {
      for (const [key, arr] of Object.entries(aiAltObj)) {
        const k = String(key).toLowerCase();
        const opts = Array.isArray(arr) ? arr.map(String) : [];
        if (!outMap.has(k)) outMap.set(k, new Set());
        const set = outMap.get(k);
        opts.forEach(o => set.add(o));
      }
    }

    // 2) From local builder (array of { simple, options })
    if (Array.isArray(localArr)) {
      localArr.forEach(({ simple, options }) => {
        const k = String(simple).toLowerCase();
        if (!outMap.has(k)) outMap.set(k, new Set());
        const set = outMap.get(k);
        (options || []).forEach(o => set.add(o));
      });
    }

    // Back to array format expected by renderAlternatives
    const merged = [];
    for (const [simple, set] of outMap.entries()) {
      merged.push({ simple, options: [...set] });
    }
    return merged;
  }
</script>


    /* ========= Correction handler: AI first, fallback to local ========= */
    window.runCorrection = async function () {
      const input = document.getElementById("inputText").value.trim();
      const lvl   = document.getElementById("levelSelect").value;
      const formal= document.getElementById("formalToggle").checked;
      const useAI = document.getElementById("aiToggle").checked && AI_ENDPOINT && AI_ENDPOINT.startsWith("https://");

      const outBox  = document.getElementById("outputText");
      const notesBox= document.getElementById("notes");
      const altBox  = document.getElementById("altList");

      if (!input) {
        outBox.value = "";
        notesBox.innerHTML = "<b>Changes:</b><br><span class='hint'>No input provided.</span>";
        altBox.innerHTML = "";
        return;
      }

      notesBox.innerHTML = "<b>Changes:</b><br><span class='hint'>Processing…</span>";
      altBox.innerHTML   = "<span class='hint'>Processing…</span>";
      outBox.value = "";

      // ===== AI path =====
      if (useAI) {
        console.log("Posting to AI endpoint:", AI_ENDPOINT, { level: lvl, formal, sample: input.slice(0, 60) + (input.length>60?"…":"") });
        try {
          const res = await fetch(AI_ENDPOINT, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ text: input, level: lvl, formal })
          });

          if (!res.ok) {
            const detail = await res.text().catch(()=>"(no body)");
            console.warn("AI call failed", res.status, detail);
            notesBox.innerHTML = `<b>AI call failed:</b> HTTP ${res.status}<br><pre style="white-space:pre-wrap">${detail}</pre><br><i>Using local rules instead.</i>`;
            const { out, notes, alts } = correctLocal(input, lvl);
            outBox.value = out;
            notesBox.innerHTML += "<br><b>Changes (local):</b><br>" + (notes.length ? notes.map(n=>"• "+n).join("<br>") : "(No major changes)");
            renderAlternatives(out, alts, (lvl === 'C1' ? 'C1' : 'B2'));
            return;
          }

          const raw = await res.text();
          console.log("AI raw response:", raw);
          let data;
          try { data = JSON.parse(raw); }
          catch(e) {
            console.warn("AI returned non-JSON", e);
            notesBox.innerHTML = `<b>AI returned non-JSON.</b><br><pre style="white-space:pre-wrap">${raw}</pre><br><i>Using local rules instead.</i>`;
            const { out, notes, alts } = correctLocal(input, lvl);
            outBox.value = out;
            notesBox.innerHTML += "<br><b>Changes (local):</b><br>" + (notes.length ? notes.map(n=>"• "+n).join("<br>") : "(No major changes)");
            renderAlternatives(out, alts, (lvl === 'C1' ? 'C1' : 'B2'));
            return;
          }

          if (data && typeof data.corrected === 'string') {
            outBox.value = data.corrected;
            notesBox.innerHTML = "<b>Changes (AI):</b><br>" + (Array.isArray(data.notes) ? data.notes.map(n=>"• "+n).join("<br>") : "(none)");

            let alts = [];
            if (data.alternatives && typeof data.alternatives === 'object' && Object.keys(data.alternatives).length) {
              alts = Object.entries(data.alternatives).map(([k, arr]) => ({ simple: k, options: Array.isArray(arr) ? arr : [] }));
            } else {
              alts = buildAlternatives(data.corrected, (lvl === 'C1' ? 'C1' : 'B2'));
            }
            renderAlternatives(data.corrected, alts, (lvl === 'C1' ? 'C1' : 'B2'));
            return; // AI succeeded
          } else {
            notesBox.innerHTML = `<b>AI response missing "corrected".</b><br><pre style="white-space:pre-wrap">${raw}</pre><br><i>Using local rules instead.</i>`;
            const { out, notes, alts } = correctLocal(input, lvl);
            outBox.value = out;
            notesBox.innerHTML += "<br><b>Changes (local):</b><br>" + (notes.length ? notes.map(n=>"• "+n).join("<br>") : "(No major changes)");
            renderAlternatives(out, alts, (lvl === 'C1' ? 'C1' : 'B2'));
            return;
          }
        } catch (e) {
          console.error("AI fetch error:", e);
          notesBox.innerHTML = `<b>AI fetch failed:</b> ${e.message}<br><i>Using local rules instead.</i>`;
          const { out, notes, alts } = correctLocal(input, lvl);
          outBox.value = out;
          notesBox.innerHTML += "<br><b>Changes (local):</b><br>" + (notes.length ? notes.map(n=>"• "+n).join("<br>") : "(No major changes)");
          renderAlternatives(out, alts, (lvl === 'C1' ? 'C1' : 'B2'));
          return;
        }
      }

      // ===== Local fallback (if AI unchecked) =====
      const { out, notes, alts } = correctLocal(input, lvl);
      outBox.value = out;
      notesBox.innerHTML = "<b>Changes:</b><br>" + (notes.length ? notes.map(n=>"• "+n).join("<br>") : "(No major changes)");
      renderAlternatives(out, alts, (lvl === 'C1' ? 'C1' : 'B2'));
    };

    /* ========= Clear / Paste / PDF ========= */
    window.clearAll=function(){
      inputText.value=""; outputText.value="";
      document.getElementById("notes").innerHTML="<b>Changes:</b><br><span class='hint'>Cleared.</span>";
      document.getElementById("altList").innerHTML="After correction, suggested upgrades will appear here (especially for C1/C2).";
    };
    window.pasteFromClipboard=async function(){
      const ta=document.getElementById("inputText");
      try{
        const text=await navigator.clipboard.readText();
        if(text){
          const start=ta.selectionStart ?? ta.value.length, end=ta.selectionEnd ?? ta.value.length;
          ta.value = ta.value.slice(0,start)+text+ta.value.slice(end);
          ta.focus(); ta.selectionStart=ta.selectionEnd=start+text.length;
        } else alert("Your clipboard is empty.");
      }catch(e){
        alert("Browser blocked clipboard. Try Ctrl/Cmd+V on desktop, or long-press → Paste on mobile.");
        console.error(e);
      }
    };
    window.downloadPDF=function(){
      try{
        const { jsPDF } = window.jspdf || {}; if(!jsPDF){ alert("PDF library failed to load."); return; }
        const doc=new jsPDF({ unit:"pt", format:"a4" }); const margin=48; let y=margin;
        doc.setFont("Helvetica","bold"); doc.setFontSize(14); doc.text("EssayCoach – Corrected Output", margin, y); y+=20;
        doc.setFont("Helvetica","normal"); doc.setFontSize(12);
        const lines=doc.splitTextToSize(document.getElementById("outputText").value || "(empty)", 595-margin*2);
        doc.text(lines, margin, y);
        doc.save("essay-corrected.pdf");
      }catch(e){ alert("Could not create PDF: "+e.message); console.error(e); }
    };

    /* ========= Init ========= */
    renderScaffold();
    window.addEventListener('load',()=>{
      const aiBox=document.getElementById('aiToggle');
      if (aiBox) {
        const hasEndpoint = AI_ENDPOINT && AI_ENDPOINT.startsWith("https://");
        if (hasEndpoint) {
          aiBox.checked = true;
          aiBox.title = "Uses your Cloudflare Worker (AI) first, then falls back to local rules.";
        } else {
          aiBox.checked = false;
          aiBox.disabled = true;
          aiBox.title = "Set AI_ENDPOINT in index.html to enable AI corrections.";
        }
      }
      if(location.hash==='#corrector') showTab('corrector'); else showTab('scaffolds');
    });

    /* ========= PWA: register Service Worker (relative path for GitHub Pages) ========= */
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('sw.js', { scope: './' }).catch(console.error);
      });
    }
    <script>window.addEventListener('error',e=>{document.body.insertAdjacentHTML('beforeend',`<pre style="white-space:pre-wrap;background:#fee;border:1px solid #f99;padding:8px;border-radius:8px;margin:12px 0">JS error: ${e.message}</pre>`);});</script>

  </script>
            <!-- Simple on-page error overlay -->
<script>
  window.addEventListener('error', (e) => {
    document.body.insertAdjacentHTML(
      'beforeend',
      `<pre style="white-space:pre-wrap;background:#fee;border:1px solid #f99;padding:10px;border-radius:8px;margin:12px 0;color:#800">
<b>JS error:</b> ${e.message}
</pre>`
    );
  });
</script>

</body>
</html>
