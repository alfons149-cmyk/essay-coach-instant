<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Essay Coach</title>
  <link rel="manifest" href="manifest.webmanifest" />
  <link rel="icon" href="icon-192.png" type="image/png" />
  <style>
    body { font-family: Arial, sans-serif; margin: 0; padding: 1rem; line-height: 1.5; background:#f9fafb;}
    h1 { text-align: center; font-size:1.5rem; }
    textarea { width: 100%; min-height: 160px; padding:0.5rem; margin:0.5rem 0; border-radius:8px; border:1px solid #ccc;}
    select, button { padding:0.5rem 1rem; margin:0.25rem; border-radius:6px; border:1px solid #333; }
    button.primary { background:#2563eb; color:white; border:none; }
    button.secondary { background:#f3f4f6; }
    #notes { background:#fff; padding:0.5rem; border:1px solid #ddd; margin-top:0.5rem; border-radius:6px; font-size:0.9rem;}
    #altList { margin-top:1rem; }
    .alt-section h4 { margin:0.5rem 0; font-size:1rem; }
    .chip { display:inline-block; margin:0.25rem; padding:0.25rem 0.5rem; border-radius:12px; background:#e5e7eb; border:none; cursor:pointer; }
    .hint { color:#666; font-size:0.85rem;}
  </style>
</head>
<body>
  <h1>Essay Coach</h1>

  <label for="levelSelect">Select Level:</label>
  <select id="levelSelect">
    <option value="B2">B2 First</option>
    <option value="C1">C1 Advanced</option>
  </select>

  <textarea id="inputText" placeholder="Write your essay text here..."></textarea>

  <div>
    <button class="primary" onclick="runCorrection()">Correct</button>
    <button class="secondary" onclick="clearText()">Clear</button>
    <button class="secondary" onclick="exportPDF()">Export PDF</button>
  </div>

  <textarea id="outputText" placeholder="Corrected text will appear here..."></textarea>

  <div id="notes">(Notes will appear here)</div>
  <div id="altList"></div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <script>
    const AI_ENDPOINT = "https://YOUR-WORKER-SUBDOMAIN.workers.dev"; // set to your Cloudflare Worker URL

    // ==== FORMAL MAP ====
    const FORMAL_MAP = [
      { re: /\bkids\b/gi, rep: "children", note: "Replaced informal 'kids' with 'children'." },
      { re: /\bOK\b|\bokay\b/gi, rep: "acceptable", note: "Replaced 'OK/okay' with 'acceptable'." },
      { re: /\ba lot of\b/gi, rep: "many", note: "Replaced 'a lot of' with 'many'." },
      { re: /\blots of\b/gi, rep: "many", note: "Replaced 'lots of' with 'many'." },
      { re: /\btons of\b/gi, rep: "a large number of", note: "Replaced 'tons of'." },
      { re: /\bstuff\b/gi, rep: "items", note: "Replaced 'stuff' with 'items'." },
      { re: /\bthings\b/gi, rep: "aspects", note: "Replaced vague 'things' with 'aspects'." },
      { re: /\bgonna\b/gi, rep: "going to", note: "Expanded 'gonna' to 'going to'." },
      { re: /\bwanna\b/gi, rep: "want to", note: "Expanded 'wanna' to 'want to'." },
      { re: /\bguys?\b/gi, rep: "people", note: "Replaced 'guy/guys' with 'people'." },
      { re: /\bpretty\b(?=\s+(?:good|bad|big|small|sure|clear|simple|hard)\b)/gi, rep: "fairly", note: "Replaced colloquial 'pretty' as an intensifier." },
      { re: /\bsort of\b|\bkinda\b|\bkind of\b/gi, rep: "", note: "Removed hedging ('sort of/kinda')." },
      { re: /\breally\b/gi, rep: "highly", note: "Upgraded 'really' to 'highly' in formal register." },
      { re: /\bvery\b/gi, rep: "particularly", note: "Upgraded 'very' to 'particularly'." },
      { re: /\bI think\b/gi, rep: "I consider", note: "Slightly formalised 'I think' to 'I consider'." },
      { re: /\bI guess\b/gi, rep: "I suppose", note: "Formalised 'I guess' to 'I suppose'." }
    ];

    // ==== BASIC RULE CORRECTOR (fallback) ====
    function correct(text, lvl) {
      let out = text.trim();
      const notes = [];

      // contractions → full form
      out = out.replace(/\b(can't)\b/gi,"cannot");
      out = out.replace(/\bwon't\b/gi,"will not");
      out = out.replace(/\bdon't\b/gi,"do not");
      out = out.replace(/\bdoesn't\b/gi,"does not");
      out = out.replace(/\bdidn't\b/gi,"did not");
      out = out.replace(/\bit's\b/gi,"it is");
      out = out.replace(/\bI'm\b/gi,"I am");

      // formal map
      FORMAL_MAP.forEach(({re,rep,note})=>{
        if(re.test(out)){ out = out.replace(re,rep); notes.push(note); }
      });

      // Introductory comma rule
      const INTRO_PHRASES = ["First","Firstly","In addition","For example","On the other hand","In conclusion","Moreover","Nevertheless","Consequently","As a result"];
      INTRO_PHRASES.forEach(phrase=>{
        const re = new RegExp(`^(${phrase})(\\s+)(?!,)`,"i");
        if(re.test(out)){
          out = out.replace(re,"$1, ");
          notes.push("Added comma after introductory phrase.");
        }
      });

      // Ensure final punctuation
      if(!/[.!?]$/.test(out)){ out+="."; notes.push("Added final punctuation."); }

      return { out, notes, alts: {} };
    }

    // ==== RUN CORRECTION (AI first, fallback to local) ====
    window.runCorrection = async function() {
      const text = document.getElementById("inputText").value;
      const lvl  = document.getElementById("levelSelect").value;
      const notesBox = document.getElementById("notes");
      const output = document.getElementById("outputText");

      // Always try AI first
      try {
        if(AI_ENDPOINT && AI_ENDPOINT.startsWith("https://")) {
          const res = await fetch(AI_ENDPOINT, {
            method:"POST", headers:{"Content-Type":"application/json"},
            body: JSON.stringify({ text, level:lvl })
          });
          const raw = await res.text();
          let obj; try{ obj=JSON.parse(raw);}catch{ obj=null;}
          if(obj && typeof obj.corrected==="string") {
            output.value = obj.corrected;
            notesBox.innerHTML = "<b>Changes (AI):</b><br>"+(obj.notes?.map(n=>"• "+n).join("<br>") || "(No details)");
            return;
          } else {
            notesBox.innerHTML = "<b>Changes:</b><br><span class='hint'>AI invalid, using local rules.</span>";
          }
        }
      } catch(e) {
        notesBox.innerHTML = "<b>Changes:</b><br><span class='hint'>AI error, using local rules.</span>";
      }

      // fallback
      const { out, notes } = correct(text,lvl);
      output.value = out;
      notesBox.innerHTML = "<b>Changes (local):</b><br>"+(notes.length?notes.map(n=>"• "+n).join("<br>"):"(No major changes)");
    };

    // ==== CLEAR ====
    function clearText(){
      document.getElementById("inputText").value="";
      document.getElementById("outputText").value="";
      document.getElementById("notes").innerHTML="(Notes will appear here)";
      document.getElementById("altList").innerHTML="";
    }

    // ==== EXPORT PDF ====
    async function exportPDF(){
      const { jsPDF } = window.jspdf;
      const doc = new jsPDF();
      doc.text(document.getElementById("outputText").value,10,10);
      doc.save("essay.pdf");
    }

    // Register SW
    if('serviceWorker' in navigator){
      navigator.serviceWorker.register('sw.js');
    }
  </script>
</body>
</html>
