<script>
"use strict";

/* ========== Small utilities ========== */
const $    = (id) => document.getElementById(id);
const t    = (k) => (window.t?.(k));
const html = (s) => (typeof escapeHtml === "function" ? escapeHtml(String(s)) : String(s));
const wc   = (s) => (String(s||"").match(/\b[\w’'-]+\b/g) || []).length;
const hasAI = () => typeof window.AI_ENDPOINT === "string" && window.AI_ENDPOINT.startsWith("https://");
const inRange = (n, a, b) => n >= a && n <= b;

/* ========== Part 2: wordcount pills ========== */
function updatePart2WordcountPills(){
  const input = ($("#p2Input")?.value || "");
  const output = ($("#p2Output")?.value || "");
  const lvl = $("#p2Level")?.value || "B2";
  const pills = (typeof p2TargetForLevel === "function") ? p2TargetForLevel(lvl) : {min:0, max: 9999, label:""};

  const inWC  = wc(input);
  const outWC = wc(output);

  const inLabel  = (t('io.input_words')  || 'Input: {n} words').replace('{n}', inWC);
  const outLabel = (t('io.output_words') || 'Output: {n} words').replace('{n}', outWC);

  const inEl  = $("#p2InWC");
  const outEl = $("#p2OutWC");
  const tEl   = $("#p2TargetWC");

  if (inEl)  inEl.textContent = inLabel;
  if (outEl) {
    outEl.textContent = outLabel;
    outEl.className = "pill";
    if (outWC > 0 && !inRange(outWC, pills.min, pills.max)) outEl.classList.add("warn");
    if (inRange(outWC, pills.min, pills.max)) outEl.classList.add("ok");
  }
  if (tEl) tEl.textContent = pills.label;
}

// live updates
["p2Input", "p2Output"].forEach(id => {
  document.addEventListener("input", (e) => {
    if (e.target && e.target.id === id) updatePart2WordcountPills();
  });
});

/* ========== Part 2: clause highlighting ========== */
function p2FindConjAdvMatches(text){
  return (typeof findConjAdvMatches === "function") ? findConjAdvMatches(text) : [];
}
function p2FindFanboysMatches(text){
  return (typeof findFanboysMatches === "function") ? findFanboysMatches(text) : [];
}

function p2CoachClauseNotes(corrected, level){
  const enabled = ($("#p2CoachNotes")?.checked !== false);
  if (!enabled || !corrected) return { notes: [], marks: [] };

  const cadv = p2FindConjAdvMatches(corrected);
  const fanb = p2FindFanboysMatches(corrected);
  const notes = [];

  cadv.forEach(({group,label,start,end})=>{
    const L = label?.trim?.() || "";
    if (group === "contrast")  notes.push(`Used “${L}” to join two clauses (C1 style) at chars ${start}–${end}.`);
    else if (group === "result")   notes.push(`Used “${L}” (result) at chars ${start}–${end}.`);
    else if (group === "addition") notes.push(`Used “${L}” (addition) at chars ${start}–${end}.`);
  });
  fanb.forEach(({label,start,end})=>{
    notes.push(`Coordinating join “${label?.trim?.()||""}” at ${start}–${end}.`);
  });

  // de-overlap & assign ids
  let marks = [...cadv, ...fanb].sort((a,b)=>a.start-b.start);
  const filtered = []; let lastEnd = -1, i = 1;
  marks.forEach(m => {
    if (m.start >= lastEnd) { m.id = `p2hl-${i++}`; filtered.push(m); lastEnd = m.end; }
  });
  return { notes, marks: filtered };
}

function p2BuildHighlightedHTML(text, marks){
  const safe = (s) => html(s).replace(/\n/g,"<br>");
  if (!marks.length) return safe(text);
  let out = "", idx = 0;
  for (const m of marks){
    out += safe(text.slice(idx, m.start));
    const inner = safe(text.slice(m.start, m.end));
    const title = html(m.label?.trim?.() || "");
    out += `<mark class="hl" id="${m.id}" title="${title}">${inner}</mark>`;
    idx = m.end;
  }
  out += safe(text.slice(idx));
  return out;
}

function p2RenderPreview(corrected, level){
  const lvl = level || $("#p2Level")?.value || "B2";
  const { notes: coach, marks } = p2CoachClauseNotes(corrected, lvl);

  const prev = $("#part2Preview");
  if (prev) prev.innerHTML = p2BuildHighlightedHTML(corrected, marks);

  const posBox = $("#p2Positions");
  if (posBox){
    if (!marks.length) posBox.innerHTML = "";
    else {
      const chips = marks.map(m=>`<a href="#" onclick="document.getElementById('${m.id}')?.scrollIntoView({behavior:'smooth',block:'center'});return false;">${m.start}–${m.end}</a>`).join(" ");
      posBox.innerHTML = `<b>${t('preview.marked_spans') || 'Marked spans:'}</b> ${chips}`;
    }
  }

  const notesBox = $("#part2Changes");
  if (notesBox && coach.length){
    if (!/Coach notes:/i.test(notesBox.innerHTML)) notesBox.innerHTML += "<br>";
    notesBox.innerHTML += "<br><b>Coach notes:</b><br>" + coach.map(n=>"• "+html(n)).join("<br>");
  }
}

/* ========== Part 2: vocab alternatives ========== */
function renderAlternativesP2(currentText, alts, level){
  const box = $("#part2Vocab");
  if (!box) return;

  if (!alts || !alts.length){
    box.innerHTML = `<span class='hint'>${t('part2.vocab_alts_wait') || 'After correction, suggested upgrades will appear here.'}</span>`;
    return;
  }

  box.innerHTML = "";
  const limitMap = { B2: 4, C1: 6, C2: 8 };

  alts.forEach(({ simple, options })=>{
    const sec = document.createElement("div"); sec.className = "alt-section";
    const h = document.createElement("h4");
    h.textContent = `“${simple}” → ${t('vocab.alternatives_title') || 'Consider alternatives:'}`;
    sec.appendChild(h);

    (options || []).slice(0, limitMap[level] || 4).forEach(opt=>{
      const chip = document.createElement("button");
      chip.className = "chip"; chip.textContent = opt;
      chip.onclick = () => {
        if (typeof wordRe !== "function") return;
        const ta = $("#p2Output");
        const base = ta?.value || currentText || "";
        const re = wordRe(simple);
        const replaced = base.replace(re, m => (m[0] === m[0].toUpperCase() ? opt[0].toUpperCase()+opt.slice(1) : opt));
        if (ta) ta.value = replaced;
        p2RenderPreview(replaced, level);
        updatePart2WordcountPills();
      };
      sec.appendChild(chip);
    });
    box.appendChild(sec);
  });
}

/* ========== Part 2: rubric ========== */
function p2GenreRubric(text, lvl, type){
  const checks = [];
  const count = wc(text);
  const target = (typeof p2TargetForLevel === "function") ? p2TargetForLevel(lvl) : {min:0,max:9999};
  const okWC = inRange(count, target.min, target.max);

  checks.push(okWC
    ? `✅ ${(t('io.output_words') || 'Output: {n} words').replace('{n}', count)}`
    : `⚠️ ${(t('io.output_words') || 'Output: {n} words').replace('{n}', count)}; ${t('part2.target') || 'target'} ${target.min}–${target.max}.`
  );

  if (type === "letter"){
    checks.push(/\bDear\b/.test(text) ? "✅ Salutation present." : "⚠️ Add an appropriate salutation (e.g., “Dear Ms X,”).");
    checks.push(/\bYours (faithfully|sincerely)\b/i.test(text) ? "✅ Formal sign-off present." : "⚠️ Add a formal sign-off (“Yours sincerely/faithfully”).");
    checks.push(/\bI am writing\b|\bI would like to\b/i.test(text) ? "✅ Purpose stated early." : "⚠️ State purpose early (“I am writing to…”).");
  } else if (type === "proposal"){
    const heads = /(Objective|Objectives|Plan|Benefits|Recommendation|Recommendations)/i.test(text);
    checks.push(heads ? "✅ Structural headings detected." : "⚠️ Use clear sections (Objectives, Plan, Benefits, Recommendations).");
    checks.push(/\brecommend(ed|ation|ations)?\b|It is recommended\b/i.test(text) ? "✅ Explicit recommendations." : "⚠️ Add explicit, actionable recommendations.");
  } else if (type === "report"){
    const sections = /(Findings|Analysis|Recommendations)/i.test(text);
    checks.push(sections ? "✅ Findings/Analysis/Recommendations present." : "⚠️ Include Findings → Analysis → Recommendations.");
    checks.push(/\b(It is|There is|There are|was|were)\b/i.test(text) ? "✅ Impersonal register appears." : "⚠️ Prefer an objective/impersonal register.");
  } else if (type === "review"){
    checks.push(/\b(recommend|worth|audience|viewers|readers)\b/i.test(text) ? "✅ Verdict/audience indicated." : "⚠️ End with a clear verdict and audience.");
    checks.push(/\b(style|pacing|voice|theme|motif|character)\b/i.test(text) ? "✅ Evaluation of craft/themes." : "⚠️ Evaluate craft/themes, not only plot.");
  }
  return checks.join("<br>");
}

function p2RenderRubric(text, lvl, type){
  const box = $("#part2Rubric");
  if (box) box.innerHTML = p2GenreRubric(String(text||""), lvl, type);
}

/* ========== Part 2: main corrector ========== */
async function runPart2Correction(){
  const input  = $("#p2Input")?.value.trim() || "";
  const lvl    = $("#p2Level")?.value || "B2";
  const type   = $("#p2Type")?.value || "essay";
  const formal = !!$("#p2Formal")?.checked;
  const useAI  = !!$("#p2UseAI")?.checked && hasAI();

  const outBox   = $("#p2Output");
  const changes  = $("#part2Changes");
  const vocabBox = $("#part2Vocab");

  if (!input){
    if (outBox) outBox.value = "";
    if (changes) changes.innerHTML = "<b>" + (t('preview.changes_title') || 'Changes:') + "</b><br><span class='hint'>" + (t('warn.no_text') || 'Paste your text to get started.') + "</span>";
    if (vocabBox) vocabBox.innerHTML = "<span class='hint'>" + (t('part2.vocab_alts_wait') || 'After correction, suggested upgrades will appear here.') + "</span>";
    const prev = $("#part2Preview"); if (prev) prev.innerHTML = "";
    const pos  = $("#p2Positions");  if (pos)  pos.innerHTML = "";
    updatePart2WordcountPills();
    return;
  }

  if (changes) changes.innerHTML = "<b>" + (t('preview.changes_title') || 'Changes:') + "</b><br><span class='hint'>Processing…</span>";
  if (vocabBox) vocabBox.innerHTML = "<span class='hint'>Processing…</span>";
  if (outBox) outBox.value = "";
  const prev = $("#part2Preview"); if (prev) prev.innerHTML = "";
  const pos  = $("#p2Positions");  if (pos)  pos.innerHTML  = "";

  // AI path
  if (useAI){
    try{
      const res = await fetch(window.AI_ENDPOINT, {
        method: "POST",
        headers: { "Content-Type":"application/json" },
        body: JSON.stringify({ text: input, level: lvl, formal, style: (typeof p2StyleFor === "function" ? p2StyleFor(lvl, type) : undefined), genre: type })
      });
      const raw = await res.text();
      if (!res.ok){
        if (changes) changes.innerHTML = `<b>AI call failed:</b> HTTP ${res.status}<br><pre style="white-space:pre-wrap">${html(raw)}</pre><br><i>Using local rules instead.</i>`;
        throw new Error("AI HTTP " + res.status);
      }

      let data;
      try { data = JSON.parse(raw); }
      catch {
        if (changes) changes.innerHTML = `<b>AI returned non-JSON:</b><br><pre style="white-space:pre-wrap">${html(raw)}</pre><br><i>Using local rules instead.</i>`;
        throw new Error("AI non-JSON");
      }

      if (data && typeof data.corrected === "string"){
        const aiOut = data.corrected;
        if (typeof _aiMadeNoChanges === "function" && _aiMadeNoChanges(input, aiOut)){
          // fallback to local if AI made no edits
          const { out, notes, alts } = (typeof correctLocal === "function") ? correctLocal(input, lvl) : { out: input, notes: [], alts: [] };
          if (outBox) outBox.value = out;
          if (changes) changes.innerHTML = "<b>" + (t('preview.changes_title') || 'Changes:') + " (local fallback – AI made no edits)</b><br>" +
            (notes.length ? notes.map(n=>"• "+html(n)).join("<br>") : "(" + (t('vocab.alternatives_wait')||'No major changes') + ")");
          const fromAI   = (data.alternatives && typeof data.alternatives === "object") ? data.alternatives : {};
          const fromLocal= (typeof buildAlternatives === "function") ? buildAlternatives(out, lvl) : {};
          const merged   = (typeof mergeAlternatives === "function") ? mergeAlternatives(fromAI, fromLocal) : (fromLocal || []);
          renderAlternativesP2(out, merged, lvl);
          p2RenderPreview(out, lvl);
          p2RenderRubric(out, lvl, type);
          updatePart2WordcountPills();
          return;
        }

        if (outBox) outBox.value = aiOut;
        const baseNotes = Array.isArray(data.notes) ? data.notes : [];
        if (changes) changes.innerHTML = "<b>" + (t('preview.changes_title') || 'Changes:') + " (AI)</b><br>" +
          (baseNotes.length ? baseNotes.map(n=>"• "+html(n)).join("<br>") : "(" + (t('vocab.alternatives_wait')||'none') + ")");

        if (Array.isArray(data.replacements) && data.replacements.length){
          changes.innerHTML += "<br><b>Upgrades:</b><br>";
          data.replacements.forEach(r=>{
            changes.innerHTML += "• Replaced “"+html(r.from)+"” → “"+html(r.to)+"”<br>";
          });
        } else if (typeof detectIntensifierNotes === "function"){
          const extra = detectIntensifierNotes(input, aiOut);
          if (extra.length) changes.innerHTML += "<br>" + extra.map(n => "• " + html(n)).join("<br>");
        }

        const fromAI    = (data.alternatives && typeof data.alternatives === "object") ? data.alternatives : {};
        const fromLocal = (typeof buildAlternatives === "function") ? buildAlternatives(aiOut, lvl) : {};
        const merged    = (typeof mergeAlternatives === "function") ? mergeAlternatives(fromAI, fromLocal) : (fromLocal || []);
        renderAlternativesP2(aiOut, merged, lvl);
        p2RenderPreview(aiOut, lvl);
        p2RenderRubric(aiOut, lvl, type);
        updatePart2WordcountPills();
        return;
      } else {
        if (changes) changes.innerHTML = `<b>AI response missing "corrected".</b><br><pre style="white-space:pre-wrap">${html(raw)}</pre><br><i>Using local rules instead.</i>`;
        throw new Error('AI missing corrected');
      }
    } catch(e){
      // fall through to local
    }
  }

  // Local path
  try{
    const { out, notes, alts } = (typeof correctLocal === "function") ? correctLocal(input, lvl) : { out: input, notes: [], alts: [] };
    if (outBox) outBox.value = out;
    const title = t('preview.changes_title') || 'Changes:';
    const body  = (notes.length ? notes.map(n=>"• "+html(n)).join("<br>") : "(" + (t('vocab.alternatives_wait')||'No major changes') + ")");
    if (changes) changes.innerHTML = "<b>"+title+" (local)</b><br>"+body;
    renderAlternativesP2(out, alts, lvl);
    p2RenderPreview(out, lvl);
    p2RenderRubric(out, lvl, type);
    updatePart2WordcountPills();
  } catch(e){
    if (changes) changes.innerHTML = `<b>Local corrector failed:</b> ${html(e.message)}`;
    if (outBox) outBox.value = input;
    updatePart2WordcountPills();
  }
}

/* ========== Part 2: helpers ========== */
function clearPart2(){
  const prev = $("#part2Preview");
  const pos  = $("#p2Positions");
  const ch   = $("#part2Changes");
  const vb   = $("#part2Vocab");
  const out  = $("#p2Output"); if (out) out.value = "";
  const inp  = $("#p2Input");  if (inp) inp.value = "";
  if (prev) prev.innerHTML = "";
  if (pos)  pos.innerHTML  = "";
  if (ch)   ch.innerHTML   = "<b>"+(t('preview.changes_title')||'Changes:')+"</b><br><span class='hint'>"+(t('btn.clear')||'Cleared')+".</span>";
  if (vb)   vb.innerHTML   = (t('part2.vocab_alts_wait') || 'After correction, suggested upgrades will appear here.');
  updatePart2WordcountPills();
}

async function pastePart2(){
  const ta = $("#p2Input"); if (!ta) return;
  try{
    const text = await navigator.clipboard.readText();
    if (text){
      const start = ta.selectionStart ?? ta.value.length;
      const end   = ta.selectionEnd   ?? ta.value.length;
      ta.value = ta.value.slice(0,start) + text + ta.value.slice(end);
      ta.focus(); ta.selectionStart = ta.selectionEnd = start + text.length;
      updatePart2WordcountPills();
    } else alert(t('warn.no_text') || "Your clipboard is empty.");
  } catch(e){
    alert(t('errors.clipboard_blocked') || "Browser blocked clipboard. Try Ctrl/Cmd+V or long-press → Paste.");
  }
}

function downloadPart2PDF(){
  try{
    const { jsPDF } = window.jspdf || {};
    if (!jsPDF){ alert(t('errors.pdf_lib_failed') || "PDF library failed to load."); return; }
    const doc = new jsPDF({ unit:"pt", format:"a4" });
    const margin = 48; let y = margin;
    doc.setFont("Helvetica","bold"); doc.setFontSize(14);
    doc.text((t('export.title') || "Correction report") + " – Part 2", margin, y); y += 20;
    doc.setFont("Helvetica","normal"); doc.setFontSize(12);
    const text = $("#p2Output")?.value || "(" + (t('warn.no_text') || 'empty') + ")";
    const lines = doc.splitTextToSize(text, 595 - margin*2);
    doc.text(lines, margin, y);
    doc.save("part2-corrected.pdf");
  } catch(e){
    alert((t('errors.pdf_failed') || "Could not create PDF: ") + e.message);
  }
}

/* ========== Shared timer (i18n) ========== */
let _timer = null, _until = 0;
function startTimer(minutes = 45){
  _until = Date.now() + minutes*60*1000;
  if (_timer) clearInterval(_timer);
  const paint = () => {
    const left = Math.max(0, _until - Date.now());
    const m = String(Math.floor(left/60000)).padStart(2,'0');
    const s = String(Math.floor((left%60000)/1000)).padStart(2,'0');
    const label = (t('io.timer_label') || 'Timer: {m}:{s}').replace('{m}', m).replace('{s}', s);
    const main = $("#timer");   if (main) main.textContent = label;
    const p2t  = $("#p2Timer"); if (p2t)  p2t.textContent  = label;
    if (left <= 0) { clearInterval(_timer); _timer = null; }
  };
  paint(); _timer = setInterval(paint, 500);
}

/* ========== Boot ========== */
try { typeof renderScaffold   === "function" && renderScaffold(); } catch {}
try { typeof renderPunctRules === "function" && renderPunctRules(); } catch {}

window.addEventListener("load", () => {
  // AI toggles
  const setAIToggle = (el) => {
    if (!el) return;
    const on = hasAI();
    el.checked = on; el.disabled = !on;
    if (!el.title) el.title = on
      ? (t('hint.ai_enabled') || "Uses your Worker (AI); falls back to local rules.")
      : (t('hint.ai_disabled') || "Set window.AI_ENDPOINT to enable AI corrections.");
  };
  setAIToggle($("#aiToggle"));
  setAIToggle($("#p2UseAI"));

  // Hash routing
  try {
    if (location.hash === "#corrector")      showTab?.("corrector");
    else if (location.hash === "#punct")     showTab?.("punct");
    else if (location.hash === "#part2")     showPart2?.();
    else                                     showTab?.("scaffolds");
  } catch {}

  // Wordcount pills (both parts)
  try { typeof updateWordPills === "function" && updateWordPills(); } catch {}
  try { updatePart2WordcountPills(); } catch {}
});

// Failsafe tab wiring
(function () {
  const tSc = $("#tab-scaffolds");
  const tCo = $("#tab-corrector");
  const tPu = $("#tab-punct");
  const tP2 = $("#tab-part2");

  function safeShow(w) {
    try { if (w === "part2") showPart2?.(); else showTab?.(w); }
    catch {
      const vs = $("#view-scaffolds");
      const vc = $("#view-corrector");
      const vp = $("#view-punct");
      const v2 = $("#view-part2");
      if (vs && vc && vp && v2){
        vs.style.display = (w==='scaffolds') ? "" : "none";
        vc.style.display = (w==='corrector') ? "" : "none";
        vp.style.display = (w==='punct')     ? "" : "none";
        v2.style.display = (w==='part2')     ? "" : "none";
      }
    }
  }
  tSc?.addEventListener("click", () => safeShow("scaffolds"));
  tCo?.addEventListener("click", () => safeShow("corrector"));
  tPu?.addEventListener("click", () => safeShow("punct"));
  tP2?.addEventListener("click", () => safeShow("part2"));
})();
</script>
