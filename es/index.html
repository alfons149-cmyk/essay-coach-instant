<!doctype html>
<html lang="es" data-theme="coral">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>EssayCoach – Cambridge Toolkit (PWA)</title>

  <!-- cache-bust -->
  <meta name="x-build" content="v2025-09-07-es-clean-unified" />

  <!-- Icons -->
  <link rel="icon" type="image/png" sizes="192x192" href="/essay-coach-instant/icon-192.png">
  <link rel="apple-touch-icon" href="/essay-coach-instant/icon-192.png">
  <link rel="manifest" href="/essay-coach-instant/manifest.webmanifest">
  <meta name="theme-color" content="#111111" />

  <!-- Locale detect -->
  <script>
  (function(){
    const isES = location.pathname.replace(/\/+$/,'').endsWith('/essay-coach-instant/es') || location.pathname.includes('/essay-coach-instant/es/');
    const lang = isES ? 'es' : 'en';
    window.CURRENT_LANG = lang;
    document.documentElement.setAttribute('lang', lang);
  })();
  </script>

  <!-- I18N loader + translator + applier (single source of truth) -->
  <script>
  window.I18N = window.I18N || {};

  (async function loadI18n(){
    const v = '2025-09-07-1'; // bump when strings change
    const lang = window.CURRENT_LANG || 'en';
    const base = '/essay-coach-instant';

    async function loadJSON(path){
      const res = await fetch(`${base}/${path}?v=${v}`, { cache: 'reload' });
      if (!res.ok) throw new Error('HTTP ' + res.status);
      return res.json();
    }

    try {
      window.I18N[lang] = await loadJSON(`${lang}.json`);
      if (lang !== 'en' && !window.I18N.en) {
        window.I18N.en = await loadJSON('en.json'); // fallback
      }

      window.t = (key)=>{
        const get=(obj,p)=>p.split('.').reduce((o,k)=>o?.[k],obj);
        return get(window.I18N[lang], key) ?? get(window.I18N.en||{}, key) ?? key;
      };

      applyI18n();
    } catch(e){
      console.error('[i18n] load failed', e);
    }
  })();

  function applyI18n(){
    document.querySelectorAll('[data-i18n]').forEach(el=>{
      const k = el.getAttribute('data-i18n');
      const txt = (window.t?.(k)) || k;
      if (el.hasAttribute('data-i18n-title')) el.setAttribute('title', txt);
      if (el.hasAttribute('data-i18n-placeholder')) el.setAttribute('placeholder', txt);
      if (el.getAttribute('data-i18n-target') === 'aria-label') el.setAttribute('aria-label', txt);
      if (el.tagName === 'INPUT' || el.tagName === 'TEXTAREA') {
        if (el.hasAttribute('placeholder')) el.setAttribute('placeholder', txt);
        else if (el.type === 'button' || el.type === 'submit' || el.type === 'reset') el.value = txt;
        else el.value = el.value || txt;
      } else {
        if (!el.children.length) el.textContent = txt;
      }
    });
  }

  document.addEventListener('DOMContentLoaded', () => {
    if (window.applyI18n) applyI18n();
    const mo = new MutationObserver(() => applyI18n());
    mo.observe(document.documentElement, { childList: true, subtree: true });
  });
  </script>

  <!-- C2 Rubric (data only) -->
  <script>
  (function(){
    const C2_RUBRIC_ES = {
      meta: {
        task: "Ensayo (C2 Proficiency, Parte 1)",
        length: "240–280 palabras",
        expects: [
          "Síntesis de dos textos (ideas clave en tus palabras)",
          "Evaluación crítica (fortalezas/limitaciones, matices)",
          "Postura clara y sostenida (tesis + conclusión)",
          "Registro formal, precisión léxica y gramatical",
          "Organización coherente con conectores variados"
        ]
      },
      bands: [
        { name:"Banda 5 (Excelente)",
          Content:"Integra con soltura ideas de ambos textos sin copiar; sintetiza con precisión y mantiene totalmente la relevancia y el propósito.",
          CommunicativeAchievement:"Tono y registro académicos impecables; clara distancia crítica; objetivo cumplido con autoridad y naturalidad.",
          Organisation:"Estructura impecable (tesis nítida, desarrollo lógico, conclusión convincente); cohesión variada y discreta.",
          Language:"Léxico amplio y preciso; colocaciones maduras; gramática compleja controlada; errores raros y no sistemáticos."
        },
        { name:"Banda 4 (Muy bueno)",
          Content:"Síntesis sólida y relevante; mínima dependencia de frases fuente; aporta valoración propia bien enfocada.",
          CommunicativeAchievement:"Registro formal consistente; propósito logrado; voz analítica clara.",
          Organisation:"Párrafos bien secuenciados; conectores variados; alguno menor desliz de flujo.",
          Language:"Amplio rango con buena precisión; alguna elección menos fina o error menor bajo control."
        },
        { name:"Banda 3 (Adecuado)",
          Content:"Resume las ideas principales con cierta dependencia del original; evaluación presente pero superficial.",
          CommunicativeAchievement:"Registro generalmente formal; el propósito se cumple aunque con momentos menos académicos.",
          Organisation:"Estructura clara pero desigual; repetición de conectores; conclusión algo débil.",
          Language:"Rango suficiente; errores ocasionales que no impiden la comunicación; precisión léxica irregular."
        },
        { name:"Banda 2 (Limitado)",
          Content:"Tratamiento parcial de las fuentes; puede omitir ideas clave o incluir irrelevancias; escasa evaluación.",
          CommunicativeAchievement:"Registro inestable; objetivo parcialmente logrado; voz poco consistente.",
          Organisation:"Coherencia frágil; orden y progresión deficientes; uso limitado de cohesión.",
          Language:"Rango limitado; errores frecuentes que distraen; uso impropio de vocabulario académico."
        },
        { name:"Banda 1 (Insuficiente)",
          Content:"No sintetiza adecuadamente; copia frases; falta relevancia o no cumple la tarea.",
          CommunicativeAchievement:"Registro inapropiado; no se logra el propósito.",
          Organisation:"Desorganizado; apenas hay cohesión; conclusión ausente.",
          Language:"Control gramatical débil; errores que entorpecen; léxico pobre o impropio."
        }
      ],
      quickChecks: {
        synthesis: "¿Has reformulado (no copiado) las ideas de ambos textos?",
        evaluation: "¿Has valorado argumentos (fortalezas/limitaciones) y añadido matices?",
        thesis: "¿Tu postura se entiende desde la introducción y se mantiene hasta la conclusión?",
        cohesion: "¿Varías conectores y referencias? (no abuses de un par de conectores)",
        register: "¿Evitas coloquialismos y mantienes precisión léxica?"
      }
    };
    window.RUBRICS = Object.assign(window.RUBRICS || {}, { C2_ES: C2_RUBRIC_ES });
  })();
  </script>

  <!-- === GLOBALS: AI endpoint === -->
  <script>
    window.AI_ENDPOINT = "https://essaycoach.alfons149.workers.dev";
  </script>

  <!-- Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&family=IBM+Plex+Serif:wght@400;600&display=swap" rel="stylesheet">

  <!-- CSS (cache-busted) -->
  <link rel="stylesheet" href="/essay-coach-instant/assets/styles.css?v=2025-09-07-1">
</head>

<body>
  <div class="wrap">
    <!-- Title + sub -->
    <h1 data-i18n="app.title">EssayCoach – Cambridge Toolkit</h1>
    <p class="sub" data-i18n="home.hero_line">
      Scaffolds • Corrector (B2–C2) • Coach notes • Highlights &amp; click-to-jump • Punctuation Rules • Guide &amp; Example • PDF
    </p>

    <!-- Tabs -->
    <div class="tabs">
      <button class="tab active" id="tab-scaffolds" onclick="showTab('scaffolds')"
              data-i18n="tabs.scaffolds">Scaffolds</button>

      <button class="tab" id="tab-corrector" onclick="showTab('corrector')"
              data-i18n="tabs.corrector">Corrector</button>

      <button class="tab" id="tab-punct" onclick="showTab('punct')"
              data-i18n="nav.punctuation">Reglas de puntuación</button>

      <button class="tab" id="tab-part2" onclick="showPart2()"
              data-i18n="part2.corrector_title">Part 2 (Letter/Email • Proposal • Report • Review)</button>
    </div>

    <!-- SCAFFOLDS TAB -->
    <section id="view-scaffolds">
      <div class="card" style="margin-bottom:12px">
        <div class="cols">
          <label>
            <div class="small" data-i18n="label.level">Level</div>
            <select id="scLevel" onchange="renderScaffold()">
              <option value="B2" data-i18n="level.b2">B2 First</option>
              <option value="C1" data-i18n="level.c1">C1 Advanced</option>
              <option value="C2" data-i18n="level.c2">C2 Proficiency</option>
            </select>
          </label>

          <label>
            <div class="small" data-i18n="label.task_type">Task type</div>
            <select id="scType" onchange="renderScaffold()">
              <option value="essay" data-i18n="task.essay">Essay</option>
              <option value="report" data-i18n="task.report">Report</option>
              <option value="review" data-i18n="task.review">Review</option>
              <option value="letter" data-i18n="task.letter_email">Formal letter/email</option>
              <option value="proposal" data-i18n="task.proposal">Proposal</option>
            </select>
          </label>
        </div>

        <div class="row" style="margin-top:12px">
          <button id="btnCopyScaffold" onclick="copyScaffold()" data-i18n="btn.copy_scaffold">Copy scaffold</button>
          <button id="btnCopyOpener" onclick="copyOpener()" data-i18n="btn.copy_opener">Copy opener</button>
          <button id="btnExportScaffoldPDF" onclick="exportScaffoldPDF()" data-i18n="btn.export_scaffold_pdf">Export scaffold as PDF</button>
          <button id="btnGuideExample" class="primary" onclick="openGuideModal()" data-i18n="btn.guide_example">Guide &amp; Example</button>
        </div>

        <div class="hint" style="margin-top:6px" data-i18n="guide.about">
          “Guide &amp; Example” shows a full model answer for the selected Level + Task type. Toggle coach notes inside the modal.
        </div>
      </div>

      <div class="card">
        <div style="font-size:12px;color:#6b7280;text-transform:uppercase;letter-spacing:.08em;margin-bottom:6px"
             data-i18n="section.structure">Structure</div>

        <h3 style="margin:0" data-i18n="section.moves_title">Recommended moves (4-part structure)</h3>

        <hr style="border:none;border-top:1px solid var(--border);margin:8px 0 14px">
        <ol id="scMoves"></ol>

        <h3 style="margin:16px 0 6px" data-i18n="section.useful_opener">Useful opener (example)</h3>
        <div id="scOpener" class="notes"></div>

        <h3 style="margin:16px 0 6px" data-i18n="section.tips">Tips</h3>
        <ul id="scTips"></ul>

        <div class="hint" data-i18n="hint.choose_level">
          Choose level and task to update the scaffold. You can copy or export to PDF.
        </div>
      </div>
    </section>

    <!-- CORRECTOR TAB -->
    <section id="view-corrector" style="display:none">
      <div class="card" style="margin-bottom:12px">
        <details id="taskSetup" open>
          <summary style="cursor:pointer;font-weight:600" data-i18n="label.task_setup">Task setup</summary>

          <div class="cols" style="margin-top:10px">
            <label>
              <div class="small" data-i18n="label.level">Level</div>
              <select id="levelSelect">
                <option value="B2" data-i18n="level.b2">B2 First</option>
                <option value="C1" data-i18n="level.c1">C1 Advanced</option>
                <option value="C2" data-i18n="level.c2">C2 Proficiency</option>
              </select>
            </label>

            <!-- Word count pills (dynamic via JS) -->
            <div class="kpi" id="wcPills">
              <div class="pill" id="inWC"  data-i18n="io.input_words">Input: 0 words</div>
              <div class="pill" id="outWC" data-i18n="io.output_words">Output: 0 words</div>
              <div class="pill small" id="essayTip" data-i18n="io.target_example_c1">Target 220–260 (C1 essay)</div>
            </div>
          </div>

          <div class="row" style="margin-top:10px">
            <button class="primary" id="btnCorrect" onclick="runCorrection()" data-i18n="btn.correct">Correct</button>
            <button id="btnExportPDF" onclick="downloadPDF()" data-i18n="btn.export_pdf">Export PDF</button>
            <button id="btnClear" onclick="clearAll()" data-i18n="btn.clear">Clear</button>
            <button id="btnPaste" onclick="pasteFromClipboard()" data-i18n="btn.paste">Paste</button>
            <button id="btnStartTimer" onclick="startTimer()" data-i18n="btn.start_timer">Start 45-min timer</button>
            <span id="timer" class="pill small" data-i18n="io.timer_dash">Timer: --:--</span>
          </div>
        </details>
      </div>

      <div class="card" style="margin-bottom:12px">
        <label style="display:block; margin-bottom:8px">
          <div class="small" data-i18n="io.input_label">Input</div>
          <textarea id="inputText" rows="7" placeholder="Type or paste your text here..." data-i18n="io.input_placeholder">Type or paste your text here...</textarea>
        </label>

        <div class="small" data-i18n="actions.title">Actions</div>
        <div class="row" style="margin-top:6px">
          <button class="primary" onclick="runCorrection()" data-i18n="btn.correct">Correct</button>
          <button onclick="downloadPDF()" data-i18n="btn.export_pdf">Export PDF</button>
          <button onclick="clearAll()" data-i18n="btn.clear">Clear</button>
          <button onclick="pasteFromClipboard()" data-i18n="btn.paste">Paste</button>
        </div>
      </div>

      <div class="card" style="margin-bottom:12px">
        <div class="small" data-i18n="io.output_label">Corrected Output (plain text)</div>
        <textarea id="outputText" rows="6" readonly placeholder="Your corrected text will appear here..." data-i18n="io.output_placeholder">Your corrected text will appear here...</textarea>

        <div class="small" style="margin:12px 0 6px" data-i18n="preview.title">
          Preview with highlights (click a chip to jump; click a highlight to toggle)
        </div>

        <div id="outputPreview" class="preview">
          <div style="color:#6b7280;font-size:14px" data-i18n="preview.instructions">
            Paste your text and press <b>Correct</b>.<br>
            We’ll highlight clause joins (FANBOYS / conjunctive adverbs) and show <em>Coach notes</em> on how to reach C1.
          </div>
        </div>

        <div id="positions" class="poslist hint"></div>

        <div class="notes" id="notes" style="margin-top:10px">
          <b data-i18n="preview.changes_title">Changes:</b><br>
          <span class="hint" data-i18n="preview.changes_wait">Corrections will appear here after you click “Correct”.</span>
        </div>
      </div>

      <!-- B2/C1/C2 quick rubric (essay) -->
      <div class="card" id="b2RubricCard" style="display:none">
        <h3 style="margin:0 0 6px" data-i18n="b2.quick_rubric_title">B2 (FCE) quick rubric – prototype</h3>
        <div id="b2Rubric" class="hint" data-i18n="b2.quick_rubric_wait">Run a correction to see feedback.</div>
      </div>
      <div class="card" id="c1RubricCard" style="display:none">
        <h3 style="margin:0 0 6px" data-i18n="c1.quick_rubric_title">C1 (CAE) quick rubric – prototype</h3>
        <div id="c1Rubric" class="hint" data-i18n="c1.quick_rubric_wait">Run a correction to see feedback.</div>
      </div>
      <div class="card" id="c2RubricCard" style="display:none">
        <h3 style="margin:0 0 6px" data-i18n="c2.quick_rubric_title">C2 (CPE) quick rubric – prototype</h3>
        <div id="c2Rubric" class="hint" data-i18n="c2.quick_rubric_wait">Run a correction to see feedback.</div>
      </div>

      <!-- Sentence-type analysis (scaffold) -->
      <div class="card" id="sentTypeCard" style="display:none">
        <h3 style="margin:0 0 6px" data-i18n="sent.types_title">Sentence type analysis (prototype)</h3>
        <div id="sentTypesBox" class="hint" data-i18n="sent.types_wait">Run a correction to analyse simple / compound / complex / compound-complex sentences. (Heuristic; replace with your classifier.)</div>
      </div>

      <div class="card">
        <h3 style="margin:0 0 6px" data-i18n="vocab.alternatives_title">Vocabulary alternatives (click to apply)</h3>
        <div id="altList" class="hint" data-i18n="vocab.alternatives_wait">After correction, suggested upgrades will appear here (especially for C1/C2).</div>
      </div>

      <!-- Toggles -->
      <div class="card" style="margin-bottom:12px">
        <label class="toggle">
          <input type="checkbox" id="formalToggle" checked />
          <span data-i18n="controls.enforce_formal">Enforce formal tone (avoid slang/colloquialisms)</span>
        </label>

        <label class="toggle">
          <input type="checkbox" id="aiToggle" />
          <span data-i18n="controls.use_ai">Use AI (ChatGPT) with exam-aligned style (requires Worker URL)</span>
        </label>

        <label class="toggle">
          <input type="checkbox" id="coachNotesToggle" checked />
          <span data-i18n="controls.show_coach_notes">Show coach notes & highlights for clause punctuation (B2↔C1)</span>
        </label>

        <div class="hint" style="margin-top:6px" data-i18n="reminder.essay_counts">
          Essay reminders: <b>B2</b> 140–190 • <b>C1</b> 220–260 • <b>C2</b> 240–280. Paraphrase prompts, organise clearly, and maintain an academic/neutral–formal voice.
        </div>
      </div>
    </section>

    <!-- ===== PUNCTUATION GUIDE ===== -->
    <section id="view-punct" style="display:none">
      <div class="card" style="margin-bottom:12px">
        <div class="row" style="justify-content:space-between;align-items:center">
          <h2 style="margin:0" data-i18n="punct.core_rules_title">Reglas básicas de puntuación (seguras para examen)</h2>
          <div>
            <button onclick="copyPunctRules()" data-i18n="punct.copy_rules">Copiar reglas</button>
            <button onclick="exportPunctPDF()" data-i18n="punct.export_rules_pdf">Exportar reglas en PDF</button>
            <button onclick="openPunctGuide()" data-i18n="punct.open_guide">Abrir guía de puntuación</button>
          </div>
        </div>

        <div id="punctRules" class="notes" style="margin-top:10px" data-i18n="punct.placeholder">
          Estos son marcadores de posición. Cámbialos por tus propias reglas más adelante.
        </div>

        <div id="punctIndex" class="hint" style="margin-top:10px"></div>
      </div>

      <div id="punctGuideModal" class="modal" style="display:none">
        <div class="modal-content">
          <div class="modal-header">
            <h3 data-i18n="punct.core_rules_title">Reglas básicas de puntuación (seguras para examen)</h3>
            <button onclick="closePunctGuide()" class="icon-btn" aria-label="Close">×</button>
          </div>
          <div id="punctGuideBody" class="modal-body"></div>
          <div class="modal-footer">
            <button onclick="copyPunctRules()" data-i18n="punct.copy_rules">Copiar reglas</button>
            <button onclick="exportPunctPDF()" data-i18n="punct.export_rules_pdf">Exportar reglas en PDF</button>
          </div>
        </div>
      </div>
    </section>

    <!-- ===== PART 2 (i18n-wired) ===== -->
    <section id="view-part2" style="display:none">
      <div class="card" style="margin-bottom:12px">
        <details id="part2Setup" open>
          <summary style="cursor:pointer;font-weight:600" data-i18n="part2.corrector_title">
            Part 2 (Letter/Email • Proposal • Report • Review)
          </summary>

          <div class="cols" style="margin-top:10px">
            <label>
              <div class="small" data-i18n="part2.level">Level</div>
              <select id="p2Level">
                <option value="B2" data-i18n="level.b2">B2 First</option>
                <option value="C1" data-i18n="level.c1">C1 Advanced</option>
                <option value="C2" data-i18n="level.c2">C2 Proficiency</option>
              </select>
            </label>

            <label>
              <div class="small" data-i18n="part2.task_type">Task type</div>
              <select id="p2Type">
                <option value="letter"   data-i18n="task.letter_email">Letter / Email</option>
                <option value="proposal" data-i18n="task.proposal">Proposal</option>
                <option value="report"   data-i18n="task.report">Report</option>
                <option value="review"   data-i18n="task.review">Review</option>
              </select>
            </label>

            <div class="kpi" id="p2WcPills">
              <div class="pill small" data-i18n="part2.tasks_line">Carta/Email, Propuesta, Informe, Reseña</div>
              <div class="pill small" data-i18n="part2.mirror_timer">El temporizador refleja el principal</div>
            </div>
          </div>

          <div class="row" style="margin-top:10px">
            <label class="toggle">
              <input type="checkbox" id="p2Formal" checked>
              <span data-i18n="part2.enforce_formal">Forzar registro formal (desactívalo para una reseña más neutral)</span>
            </label>

            <label class="toggle">
              <input type="checkbox" id="p2UseAI">
              <span data-i18n="part2.use_ai">Usar IA (ChatGPT) con género alineado (requiere Worker URL)</span>
            </label>

            <label class="toggle">
              <input type="checkbox" id="p2CoachNotes" checked>
              <span data-i18n="part2.show_coach_notes">Mostrar notas del entrenador y resaltados para la puntuación entre cláusulas</span>
            </label>
          </div>

          <div class="hint" style="margin-top:8px" data-i18n="part2.wordcount_note">
            Word count targets…
          </div>

          <div class="row" style="margin-top:10px">
            <button class="primary" id="p2Correct" onclick="runPart2Correction()" data-i18n="btn.correct">Correct</button>
            <button id="p2ExportPDF" onclick="downloadPart2PDF()" data-i18n="btn.export_pdf">Export PDF</button>
            <button id="p2Clear" onclick="clearPart2()" data-i18n="btn.clear">Clear</button>
            <button id="p2Paste" onclick="pastePart2()" data-i18n="btn.paste">Paste</button>
            <span id="p2Timer" class="pill small" data-i18n="io.timer_dash">Timer: --:--</span>
          </div>
        </details>
      </div>

      <div class="card" style="margin-bottom:12px">
        <div class="small" data-i18n="io.input_label">Input</div>
        <textarea id="p2Input" rows="6" placeholder="Paste or type your Part 2 draft…" data-i18n="io.input_placeholder">Paste or type your Part 2 draft…</textarea>
      </div>

      <div class="card" style="margin-bottom:12px">
        <div class="small" data-i18n="io.output_label">Corrected Output (plain text)</div>
        <textarea id="p2Output" rows="6" readonly placeholder="Your corrected text will appear here..." data-i18n="io.output_placeholder">Your corrected text will appear here...</textarea>

        <div class="small" style="margin:12px 0 6px" data-i18n="part2.preview_title">Vista previa con resaltados</div>
        <div id="part2Preview" class="preview">
          <div style="color:#6b7280;font-size:14px" data-i18n="part2.preview_hint">
            Pega tu texto y pulsa Corregir para ver las uniones de cláusulas y las notas del entrenador.
          </div>
        </div>

        <div id="p2Positions" class="poslist hint"></div>
        <div class="notes" id="part2Changes" style="margin-top:10px">
          <b data-i18n="preview.changes_title">Changes:</b><br>
          <span class="hint" data-i18n="part2.changes_wait">Las correcciones aparecerán aquí después de pulsar “Corregir”.</span>
        </div>
      </div>

      <div class="card" id="p2RubricCard" style="display:block">
        <h3 style="margin:0 0 6px" data-i18n="part2.quick_rubric_title">Rúbrica rápida de la Parte 2 – comprobaciones por género</h3>
        <div id="part2Rubric" class="hint" data-i18n="part2.quick_rubric_wait">
          Ejecuta una corrección para ver retroalimentación específica para carta/propuesta/informe/reseña.
        </div>
      </div>

      <div class="card">
        <h3 style="margin:0 0 6px" data-i18n="part2.vocab_alts_title">Alternativas de vocabulario (haz clic para aplicar)</h3>
        <div id="part2Vocab" class="hint" data-i18n="part2.vocab_alts_wait">
          Tras la corrección, aparecerán mejoras sugeridas.
        </div>
      </div>
    </section>
  </div>

  <!-- Guide & Example Modal -->
  <div id="guideOverlay" class="modal-overlay" aria-hidden="true">
    <div class="modal" role="dialog" aria-modal="true" aria-labelledby="guideTitle">
      <div class="modal-header">
        <div class="modal-title" id="guideTitle" data-i18n="modal.guide_title">Guide &amp; Example</div>
        <div class="modal-controls">
          <label title="Show inline coach notes that contrast B2 vs C1 phrasing" data-i18n-title="controls.show_coach_notes">
            <input type="checkbox" id="coachToggle" onchange="renderGuideExample()" />
            <span data-i18n="controls.show_coach_notes">Coach notes (B2/C1 phrasing)</span>
          </label>
        </div>
        <button class="xbtn" aria-label="Close" onclick="closeGuideModal()" data-i18n="modal.close">×</button>
      </div>
      <div class="modal-body">
        <div id="guideMeta" class="hint" style="margin-bottom:8px;"></div>
        <div id="guideExample" class="example-box" style="min-height:160px;"></div>
      </div>
      <div class="modal-actions">
        <button class="primary" onclick="copyGuide()" data-i18n="modal.copy_example">Copy example</button>
        <button onclick="exportGuidePDF()" data-i18n="modal.export_example_pdf">Export example as PDF</button>
        <button onclick="closeGuideModal()" data-i18n="modal.close">Close</button>
      </div>
    </div>
  </div>

  <!-- jsPDF -->
  <script src="https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js" crossorigin="anonymous"></script>

  <!-- ========= Tabs ========= -->
  <script>
  function showTab(which){
    document.getElementById('tab-scaffolds').classList.toggle('active', which==='scaffolds');
    document.getElementById('tab-corrector').classList.toggle('active', which==='corrector');
    document.getElementById('tab-punct').classList.toggle('active', which==='punct');
    document.getElementById('tab-part2').classList.remove('active');
    document.getElementById('view-scaffolds').style.display  = (which==='scaffolds') ? '' : 'none';
    document.getElementById('view-corrector').style.display  = (which==='corrector') ? '' : 'none';
    document.getElementById('view-punct').style.display      = (which==='punct') ? '' : 'none';
    document.getElementById('view-part2').style.display      = 'none';
    try { history.replaceState(null, "", "#" + which); } catch {}
  }
  function showPart2(){
    document.getElementById('view-scaffolds').style.display='none';
    document.getElementById('view-corrector').style.display='none';
    document.getElementById('view-punct').style.display='none';
    document.getElementById('view-part2').style.display='';
    document.getElementById('tab-scaffolds').classList.remove('active');
    document.getElementById('tab-corrector').classList.remove('active');
    document.getElementById('tab-punct').classList.remove('active');
    document.getElementById('tab-part2').classList.add('active');
    try { history.replaceState(null, "", "#part2"); } catch {}
  }
  </script>

  <!-- ========= Scaffolds (data + modal) ========= -->
  <script>
  const SCAFFOLDS = {
    B2: {
      essay: { moves: [
        "Introduction: Paraphrase the question; give a clear opinion.",
        "Body 1: First main point + short example/evidence.",
        "Body 2: Second main point + short example/evidence.",
        "Conclusion: Summarise and restate your opinion."
      ],
      opener: "In recent years, the question of [topic] has received considerable attention. In my view, [your opinion], because [reason].",
      tips: [
        "Use clear topic sentences at the start of each paragraph.",
        "Avoid contractions and slang; use formal linkers (however, in addition, therefore).",
        "Keep sentences concise; prefer clarity over complexity."
      ]},
      report: { moves:[
        "Introduction: Purpose and who the report is for.",
        "Findings 1: Current situation/results.",
        "Findings 2: Problems/positives.",
        "Recommendations: Specific, practical suggestions."
      ],
      opener:"The aim of this report is to evaluate [place/system] and to suggest improvements based on recent feedback.",
      tips:["Use headings and bullet points if allowed.","Be objective and concise; avoid personal anecdotes.","Use formal register: 'It is recommended that…'"]},
      review: { moves:[
        "Intro: Title/creator/genre + overall verdict.",
        "Paragraph 1: Brief summary (no spoilers).",
        "Paragraph 2: Evaluation (strengths/weaknesses).",
        "Conclusion: Who would enjoy it + rating."
      ],
      opener:"[Title] is a [genre] that succeeds because of its [feature], offering a [tone] experience for the audience.",
      tips:["Balance description and evaluation.","Use precise adjectives and avoid repetition.","End with a clear recommendation."]},
      letter: { moves:[
        "Greeting (Dear Sir/Madam / Dear Ms X).",
        "Opening: Reason for writing.",
        "Body: Key points in logical order.",
        "Closing: Action/request + formal sign-off."
      ],
      opener:"Dear Sir or Madam, I am writing to enquire about [topic], particularly regarding [specific detail].",
      tips:["Match tone to the reader; use formal phrases.","Close with: 'I look forward to your response.'","Sign off: 'Yours faithfully' / 'Yours sincerely'."]},
      proposal: { moves:[
        "Background & need: brief context; what problem to solve.",
        "Objective: what the proposal aims to achieve.",
        "Plan: actions/steps, timeline, resources.",
        "Benefits & conclusion: impact and clear call to proceed."
      ],
      opener:"This proposal outlines a practical plan to improve [area], addressing [need] with clear steps and measurable benefits.",
      tips:["Keep aims specific and measurable.","Use headings/bullets for clarity.","Justify each step with a short reason."]}
    },
    C1: {
      essay: { moves:[
        "Introduction: Contextualise the issue; define the scope.",
        "Body 1: Develop first argument with analysis and support.",
        "Body 2: Counter-argument or complementary argument with synthesis.",
        "Conclusion: Weigh points; deliver a nuanced final stance."
      ],
      opener:"While opinions differ regarding [topic], this essay argues that [your position] because [reason(s)], provided that [qualifier if needed].",
      tips:["Use a wide range of cohesive devices (nevertheless, consequently).","Develop ideas with cause–effect and exemplification.","Maintain precise register; avoid vague verbs."]},
      report: { moves:[
        "Purpose & methods (who/what/when).",
        "Findings (data + patterns).",
        "Analysis (implications/causes).",
        "Recommendations (prioritised, actionable)."
      ],
      opener:"This report assesses [programme/process] using [method], highlighting key outcomes and areas requiring action.",
      tips:["Use data where possible (percentages, trends).","Prioritise recommendations and justify them.","Avoid first-person unless specified."]},
      review: { moves:[
        "Hook + brief context.",
        "Overview (no spoilers) + craft elements (style, pacing, voice).",
        "Evaluation (themes, impact) with examples.",
        "Verdict (audience + comparative judgement)."
      ],
      opener:"Combining [quality] with [quality], [Title] interrogates [theme] and ultimately delivers a compelling [genre] experience.",
      tips:["Vary sentence structure for rhythm and emphasis.","Use precise terminology (narrator, motif, register).","Compare/contrast with similar works for depth."]},
      letter: { moves:[
        "Appropriate salutation + clear purpose.",
        "Developed points with well-sequenced paragraphs.",
        "Tone/register control for the reader and purpose.",
        "Close with a firm next step and formal sign-off."
      ],
      opener:"Dear [Title + Surname], I am writing in connection with [topic], and I would appreciate clarification on [specific details].",
      tips:["Maintain formal register throughout.","Employ hedging where appropriate (I would suggest / It appears that…).","End with a clear call to action."]},
      proposal: { moves:[
        "Rationale: situate the problem; define scope and constraints.",
        "Objectives & metrics: success criteria and how to measure them.",
        "Implementation plan: phases, owners, resources, risk mitigation.",
        "Value & close: cost–benefit, strategic alignment, next steps."
      ],
      opener:"This proposal recommends targeted steps to enhance [area], aligning with [goal/strategy] and delivering measurable outcomes.",
      tips:["Make objectives and measures explicit.","Sequence actions and pre-empt risks.","Argue value with precise, professional register."]}
    },
    C2: {
      essay: {
        moves:[
          "Introduction: Frame the debate raised by both texts and state a clear, reasoned position.",
          "Body A: Summarise Text 1’s key claim(s) in your own words → evaluate assumptions/strength of evidence.",
          "Body B: Summarise Text 2 → evaluate → synthesise with Text 1 (agreements/tensions).",
          "Conclusion: On balance, deliver a justified position answering the task (keep 240–280 words)."
        ],
        opener:"The two texts consider [topic] from different angles. While the first suggests [core idea], the second argues [core idea]. On balance, this essay contends that [position], given [two reasons].",
        tips:[
          "Use your own words; avoid lifting phrases.",
          "Blend: do not alternate ‘Text 1… Text 2…’ without synthesis.",
          "Use evaluative language and hedging (plausible, appears, limited by…).",
          "Stay within 240–280 words."
        ]
      },
      report:  { moves:["C2 Part 1 focuses on the Essay (two-text synthesis)."], opener:"Choose ‘Essay’.", tips:["N/A for Part 1."] },
      review:  { moves:["C2 Part 1 focuses on the Essay."], opener:"Choose ‘Essay’.", tips:["N/A for Part 1."] },
      letter:  { moves:["C2 Part 1 focuses on the Essay."], opener:"Choose ‘Essay’.", tips:["N/A for Part 1."] },
      proposal:{ moves:["C2 Part 1 focuses on the Essay."], opener:"Choose ‘Essay’.", tips:["N/A for Part 1."] }
    }
  };

  const HINTS = {
    contrast: { B2: "However", C1: "Nevertheless" },
    add:      { B2: "In addition", C1: "Moreover" },
    result:   { B2: "As a result", C1: "Consequently" },
    purpose:  { B2: "The aim of this", C1: "The purpose of this" },
    propose:  { B2: "I suggest", C1: "I would recommend" },
    formal_req:{ B2:"I would like to ask", C1:"I would appreciate clarification" },
    conclude: { B2:"To sum up", C1:"On balance" }
  };
  function injectHints(template, level, showNotes){
    return template.replace(/\{\{(\w+)\}\}/g, (_, key) => {
      const map = HINTS[key]; if(!map) return _;
      const chosen = map[level] || ""; if(!showNotes) return chosen;
      const otherLevel = level === "B2" ? "C1" : "B2"; const other = map[otherLevel] || "";
      return `${chosen} <span class="inline-note">[Coach note: ${otherLevel} phrasing: “${other}”]</span>`;
    });
  }

  const EXAMPLES = {
    B2: { /* ... (unchanged examples from your file) ... */ },
    C1: { /* ... (unchanged examples from your file) ... */ },
    C2: { /* ... (unchanged examples from your file) ... */ }
  };

  function openGuideModal(){ renderGuideExample(); const ov=document.getElementById('guideOverlay'); ov.style.display='flex'; ov.setAttribute('aria-hidden','false'); }
  function closeGuideModal(){ const ov=document.getElementById('guideOverlay'); ov.style.display='none'; ov.setAttribute('aria-hidden','true'); }
  function renderGuideExample(){
    const lvl = document.getElementById('scLevel').value;
    const typ = document.getElementById('scType').value;
    const showNotes = document.getElementById('coachToggle').checked;

    const cap = typ ? typ[0].toUpperCase()+typ.slice(1) : '';
    const meta = `${lvl} • ${cap}`;
    document.getElementById('guideMeta').textContent = meta;

    const raw = (EXAMPLES[lvl] && EXAMPLES[lvl][typ]) ? EXAMPLES[lvl][typ] : (t('guide.no_example') || "No example available.");
    const rendered = (lvl==='C2') ? raw : injectHints(raw, lvl, showNotes);

    const box = document.getElementById('guideExample');
    box.innerHTML = escapeHtml(rendered)
      .replace(/\n/g, "<br>")
      .replace(/&lt;span class=&quot;inline-note&quot;&gt;([^]+?)&lt;\/span&gt;/g,'<span class="inline-note">$1</span>');

    const title = (t('modal.guide_title') || 'Guide & Example') + (cap ? ` – ${cap}` : '');
    document.getElementById('guideTitle').textContent = title;
  }
  function copyGuide(){
    const tmp=document.createElement('div');
    tmp.innerHTML=document.getElementById('guideExample').innerHTML.replace(/<br>/g,"\n");
    const text=tmp.textContent||tmp.innerText||"";
    navigator.clipboard?.writeText(text);
    alert(t('modal.copy_done') || "Example copied.");
  }
  function exportGuidePDF(){
    const { jsPDF } = window.jspdf || {};
    if(!jsPDF){ alert(t('errors.pdf_lib') || "PDF library failed to load."); return; }

    const doc=new jsPDF({ unit:"pt", format:"a4" }); const margin=48; let y=margin;
    const title=document.getElementById('guideTitle').textContent || (t('modal.guide_title') || "Guide & Example");
    const tmp=document.createElement('div');
    tmp.innerHTML=document.getElementById('guideExample').innerHTML.replace(/<br>/g,"\n");
    const body=(tmp.textContent||"").trim();

    doc.setFont("Helvetica","bold"); doc.setFontSize(16); doc.text(title, margin, y); y+=20;
    doc.setFont("Helvetica","normal"); doc.setFontSize(12);
    const lines=doc.splitTextToSize(body, 595-margin*2);
    doc.text(lines, margin, y);
    doc.save("guide-example.pdf");
  }

  /* ========= Utilities ========= */
  const escapeHtml = (s) => String(s).replace(/[&<>\"']/g, (m)=>({ "&":"&amp;","<":"&lt;",">":"&gt;","\"":"&quot;","'":"&#039;" }[m]));
  const hasFiniteVerb = (s) => /\b(am|is|are|was|were|be|been|being|do|does|did|has|have|had|can|could|will|would|shall|should|may|might|must)\b/i.test(s) || /\b\w+(ed|s)\b/i.test(s);
  const normalizeText = (s) => String(s).replace(/[\u2018\u2019\u2032]/g,"'").replace(/[\u201C\u201D\u2033]/g,'"').replace(/\u00A0/g," ");

  function fixAAn(text){
    const silentH=/^(honest|honour|honor|hour|heir|herb)\b/i;
    const youSound=/^(uni(vers|form|que|on)|u[bcdfgklmnprstvy]|euro|eure|euph|eulog|ukulele|user|use|one|once|ufo)\b/i;
    const acronym=/^[AEFHILMNORSX]/;
    return text.replace(/\b([Aa]n?)\s+([A-Za-z][\w-]*)/g,(m,art,word)=>{
      const wl=word.toLowerCase(); let shouldBeAn=/^[aeiou]/.test(wl)||silentH.test(wl);
      if (/^[A-Z]{2,}$/.test(word)) shouldBeAn = acronym.test(word[0]);
      if (youSound.test(wl)) shouldBeAn=false;
      const desired = shouldBeAn ? (art[0]==='A'?'An':'an') : (art[0]==='A'?'A':'a');
      if ((art.toLowerCase()==='an')!==shouldBeAn) return desired+" "+word; return m;
    });
  }

  function formalize(text, notes){
    let out=text;
    const rules=[
      { re:/\bkids\b/gi, rep:"children", note:"Replaced informal 'kids'." },
      { re:/\bwanna\b/gi, rep:"want to", note:"Expanded 'wanna'." },
      { re:/\bgonna\b/gi, rep:"going to", note:"Expanded 'gonna'." },
      { re:/\bokay\b|\bOK\b/gi, rep:"acceptable", note:"Formalised 'OK/okay'." },
      { re:/\ba lot of\b/gi, rep:"many", note:"Replaced 'a lot of' with 'many'." }
    ];
    for (const r of rules){ if (r.re.test(out)){ out=out.replace(r.re,r.rep); notes.push(r.note); } }
    return out;
  }

  /* ========= Alternatives & helpers ========= */
  const ALT_MAP = {
    base: {
      "good":["effective","beneficial","favourable","advantageous"],
      "bad":["detrimental","problematic","adverse","unsatisfactory"],
      "very":["particularly","highly","notably"],
      "really":["truly","genuinely"],
      "truly":["genuinely","indeed"],
      "actually":["in fact","indeed"],
      "extremely":["exceptionally","remarkably"],
      "help":["assist","support","enable","facilitate"],
      "use":["utilise","employ","apply"],
      "say":["state","argue","contend","maintain"],
      "thing":["aspect","element","factor","component"]
    },
    c1: {
      "important":["crucial","vital","essential","pivotal"],
      "because":["since","as","given that"],
      "so":["therefore","thus","consequently"],
      "many":["numerous","a multitude of"]
    },
    c2: {
      "seems":["appears","would seem","it is plausible that"],
      "important":["salient","pivotal","of consequence"],
      "problem":["shortcoming","limitation","drawback"],
      "shows":["demonstrates","indicates","attests to"],
      "people":["stakeholders","respondents","participants"],
      "think":["contend","maintain","posit","concede"],
      "result":["upshot","ramification","implication"]
    }
  };
  const wordRe = (w)=> new RegExp("\\b" + w.replace(/[.*+?^${}()|[\\]\\\\]/g, "\\$&") + "\\b","gi");

  function buildAlternatives(text, level){
    const dicts=[ALT_MAP.base, ...(level==='C1'?[ALT_MAP.c1]:[]), ...(level==='C2'?[ALT_MAP.c2]:[])];
    const out=[]; dicts.forEach(d=>Object.entries(d).forEach(([k,arr])=>{ if (wordRe(k).test(text)) out.push({ simple:k, options:arr }); }));
    return out;
  }
  function mergeAlternatives(aiAltObj, localArr) {
    const outMap = new Map();
    if (aiAltObj && typeof aiAltObj === 'object') {
      for (const [key, arr] of Object.entries(aiAltObj)) {
        const k = String(key).toLowerCase();
        const opts = Array.isArray(arr) ? arr.map(String) : [];
        if (!outMap.has(k)) outMap.set(k, new Set());
        const set = outMap.get(k); opts.forEach(o => set.add(o));
      }
    }
    if (Array.isArray(localArr)) {
      localArr.forEach(({ simple, options }) => {
        const k = String(simple).toLowerCase();
        if (!outMap.has(k)) outMap.set(k, new Set());
        const set = outMap.get(k); (options || []).forEach(o => set.add(o));
      });
    }
    const merged = []; for (const [simple, set] of outMap.entries()) merged.push({ simple, options: [...set] });
    return merged;
  }

  /* ========= Highlights & coach notes (Part 1 panel) ========= */
  const ADV_GROUPS = {
    contrast: ["however","nevertheless","nonetheless","instead","still"],
    result:   ["therefore","consequently","thus","accordingly","otherwise"],
    addition: ["moreover","furthermore","meanwhile"]
  };
  const FANBOYS_SET = new Set(["but","so","and","yet","or"]);
  let hiddenIds = new Set();
  let currentMarks = [];

  function findConjAdvMatches(text){
    const hits=[]; const lower=text.toLowerCase();
    for(const [group, list] of Object.entries(ADV_GROUPS)){
      list.forEach(adv=>{ const re=new RegExp(`;\\s*${adv}\\s*,`,'g'); let m; while((m=re.exec(lower))!==null){ hits.push({type:'cadv', group, start:m.index, end:m.index+m[0].length, label:`; ${adv},`}); } });
    }
    return hits;
  }
  function findFanboysMatches(text){
    const hits=[]; const lower=text.toLowerCase();
    FANBOYS_SET.forEach(cj=>{ const re=new RegExp(`,\\s*${cj}\\s+`,'g'); let m; while((m=re.exec(lower))!==null){ hits.push({type:'fanboys', conj:cj, start:m.index, end:m.index+m[0].length, label:m[0]}); } });
    return hits;
  }
  function coachClauseNotes(corrected, level) {
    const show = document.getElementById('coachNotesToggle')?.checked !== false;
    if (!show || !corrected) return { notes: [], marks: [] };
    const cadv=findConjAdvMatches(corrected); const fanb=findFanboysMatches(corrected);
    const notes=[];
    cadv.forEach(({group,label,start,end})=>{
      if (group==='contrast') notes.push(`Used “${label.trim()}” to join two clauses (C1 style) at chars ${start}–${end}. B2 alternative: “, but …”.`);
      else if (group==='result') notes.push(`Used “${label.trim()}” (C1 style) at chars ${start}–${end}. B2 alternative: “, so …”.`);
      else if (group==='addition') notes.push(`Used “${label.trim()}” for addition (C1 style) at chars ${start}–${end}. B2 alternative: “, and …”.`);
    });
    fanb.forEach(({conj,label,start,end})=>{
      if (conj==='but') notes.push(`Used “${label.trim()}” (B2 solid) at chars ${start}–${end}. C1 upgrade: “; however, … / ; nevertheless, …”.`);
      else if (conj==='so') notes.push(`Used “${label.trim()}” (B2 solid) at chars ${start}–${end}. C1 upgrade: “; therefore, … / ; consequently, …”.`);
      else if (conj==='and') notes.push(`Used “${label.trim()}” at chars ${start}–${end}. C1 addition upgrade: “; moreover, … / ; furthermore, …”.`);
      else if (conj==='yet') notes.push(`Used “${label.trim()}” at chars ${start}–${end}. C1 contrast: “; however, … / ; nonetheless, …”.`);
      else if (conj==='or') notes.push(`Used “${label.trim()}” at chars ${start}–${end}. Consider precision depending on meaning (contrast/result).`);
    });
    let marks=[...cadv, ...fanb].sort((a,b)=>a.start-b.start);
    const filtered=[]; let lastEnd=-1, counter=1; marks.forEach(m=>{ if(m.start>=lastEnd){ m.id = `hl-${counter++}`; filtered.push(m); lastEnd=m.end; } });
    return { notes, marks: filtered };
  }
  function buildHighlightedHTML(text, marks){
    if(!marks.length) return escapeHtml(text).replace(/\n/g,'<br>');
    let html='', idx=0;
    for(const m of marks){
      html += escapeHtml(text.slice(idx, m.start)).replace(/\n/g,'<br>');
      const off = hiddenIds.has(m.id) ? ' off' : '';
      html += `<mark class="hl${off}" id="${m.id}" title="${escapeHtml(m.label.trim())}">${escapeHtml(text.slice(m.start, m.end))}</mark>`;
      idx = m.end;
    }
    html += escapeHtml(text.slice(idx)).replace(/\n/g,'<br>');
    return html;
  }
  function renderPreviewAndPositions(corrected, level){
    const { notes: coach, marks } = coachClauseNotes(corrected, level || document.getElementById('levelSelect').value);
    const signature = corrected.length + ':' + (marks.map(m=>m.start+'-'+m.end).join('|'));
    if (window._lastSignature !== signature) { hiddenIds.clear(); window._lastSignature = signature; }
    currentMarks = marks;

    document.getElementById('outputPreview').innerHTML = buildHighlightedHTML(corrected, marks);

    const posBox = document.getElementById('positions');
    if (!marks.length) posBox.innerHTML = "";
    else {
      const chips = marks.map(m=>{ const off = hiddenIds.has(m.id) ? 'off' : ''; return `<a href="#" data-target="${m.id}" class="${off}">${m.start}–${m.end}</a>`; }).join(' ');
      const label = t?.('preview.marked_spans') || 'Marked spans:';
      const showAll = t?.('preview.show_all') || 'Show all';
      const hideAll = t?.('preview.hide_all') || 'Hide all';
      posBox.innerHTML = `<b>${label}</b> ${chips} <span class="controls"><button onclick="showAllHighlights()">${showAll}</button><button onclick="hideAllHighlights()">${hideAll}</button></span>`;
    }

    const notesBox = document.getElementById('notes');
    if (notesBox.innerHTML.includes("<b>Changes")){
      const existingCoach = /<br><br><b>Coach notes:[\s\S]*$/i;
      notesBox.innerHTML = notesBox.innerHTML.replace(existingCoach, "");
      if (coach.length) notesBox.innerHTML += "<br><br><b>Coach notes:</b><br>" + coach.map(n=>"• "+n).join("<br>");
    }
  }
  document.addEventListener('click', (e)=>{
    if (e.target && e.target.matches('mark.hl')) {
      const id = e.target.id; if (!id) return;
      e.preventDefault();
      if (e.target.classList.contains('off')) { e.target.classList.remove('off'); hiddenIds.delete(id); }
      else { e.target.classList.add('off'); hiddenIds.add(id); }
      const chip = document.querySelector(`.poslist a[data-target="${id}"]`);
      if (chip) chip.classList.toggle('off');
    }
    if (e.target && e.target.matches('.poslist a[data-target]')) {
      e.preventDefault();
      const id = e.target.getAttribute('data-target');
      const el = document.getElementById(id);
      if (el) {
        el.classList.remove('off'); hiddenIds.delete(id);
        el.scrollIntoView({ behavior: 'smooth', block: 'center' });
        el.classList.add('focus'); setTimeout(()=> el.classList.remove('focus'), 1100);
        e.target.classList.remove('off');
      }
    }
  });
  function showAllHighlights(){ hiddenIds.clear(); document.querySelectorAll('mark.hl.off').forEach(el=>el.classList.remove('off')); document.querySelectorAll('.poslist a.off').forEach(el=>el.classList.remove('off')); }
  function hideAllHighlights(){ currentMarks.forEach(m=>hiddenIds.add(m.id)); document.querySelectorAll('mark.hl').forEach(el=>el.classList.add('off')); document.querySelectorAll('.poslist a').forEach(el=>el.classList.add('off')); }

  /* ========= Local rules corrector ========= */
  const INTRO_SINGLE=["First","Firstly","Second","Secondly","Third","Finally","Next","Then","Afterwards","Overall","Currently","Recently","Ultimately","Consequently","Therefore","However","Moreover","Furthermore","Nevertheless","Meanwhile","Instead","Still"];
  const INTRO_PHRASES=["In addition","In conclusion","In contrast","By contrast","For example","For instance","To begin with","In my opinion","On the one hand","On the other hand","As a result","In other words","In summary","On balance","At first","In general"];
  const FANBOYS=["for","and","nor","but","or","yet","so"];
  const SUBORD=["although","though","because","since","when","while","if","unless","after","before","once","whereas","as"];
  const CADV=["however","therefore","moreover","nevertheless","consequently","furthermore","nonetheless","accordingly","thus","otherwise","meanwhile","instead","still"];

  function correctLocal(text, lvl){
    if(!text || !text.trim()) return { out:"", notes:[], alts:[] };
    let out = normalizeText(text.trim()); const notes=[];

    // 1) Expand common contractions (formality)
    const CONTR = {
      "can't":"cannot","won't":"will not","don't":"do not","doesn't":"does not","didn't":"did not",
      "it's":"it is","I'm":"I am","you're":"you are","we're":"we are","they're":"they are",
      "I've":"I have","we've":"we have","they've":"they have"
    };
    for (const [k,v] of Object.entries(CONTR)){
      const re=new RegExp(`\\b${k.replace(/[-\/\\^$*+?.()|[\]{}]/g,"\\$&")}\\b`,"gi");
      const before=out;
      out=out.replace(re,(m)=>m[0]===m[0].toUpperCase()?v[0].toUpperCase()+v.slice(1):v);
      if(out!==before) notes.push(t('changes.expanded_contractions') || "Expanded contractions for formality.");
    }

    // spacing & basics
    const bs=out;
    out=out.replace(/\s+([,;:.!?])/g,"$1")
           .replace(/([,;:.!?])(\S)/g,"$1 $2")
           .replace(/\s{2,}/g," ");
    if(out!==bs) notes.push(t('changes.normalised_spacing') || "Normalised spacing.");

    const btv=out; out=out.replace(/\btv\b/gi,"TV");
    if(out!==btv) notes.push(t('changes.capitalised_tv') || "Capitalised 'TV'.");

    const baa=out; out=fixAAn(out);
    if(out!==baa) notes.push(t('changes.fixed_a_an') || "Fixed 'a/an'.");

    out = formalize(out, notes);

    // Add comma after common introductory single words / phrases
    const punctIntro=(t0)=>t0.replace(/([^.!?]+)([.!?]|$)/g,(m,core,end)=>{
      let s=core.trim();
      for(const ph of INTRO_PHRASES){
        const re=new RegExp(`^(${ph})\\s+(?!,)`,"i");
        if(re.test(s)) s=s.replace(re,`$1, `);
      }
      const fw=(s.match(/^(\w+)\s+(?!,)/)||[null,null])[1];
      if(fw && INTRO_SINGLE.includes(fw)) s=s.replace(/^(\w+)\s+(?!,)/,`$1, `);
      return s+(end||"");
    });
    const bi=out; out=punctIntro(out);
    if(out!==bi) notes.push(t('changes.added_intro_comma') || "Added comma after introductory phrase.");

    // Clause punctuation: conjunctive adverbs ; however, … and FANBOYS , but …
    const punctClauses=(t0)=>t0.replace(/([^.!?]+)([.!?]|$)/g,(m,core,end)=>{
      let s=core.trim();

      // Upgrade to ; ADV, when both sides look like finite clauses
      for(const adv of CADV){
        const re=new RegExp(`\\b${adv}\\b`,"i");
        const hit=s.match(re);
        if(hit){
          const idx=hit.index, w=hit[0];
          const L=s.slice(0,idx).replace(/[ ,;]+$/," ").trim();
          const R=s.slice(idx+w.length).replace(/^[ ,;]+/," ").trim();
          if (hasFiniteVerb(L) && hasFiniteVerb(R)){ s=`${L}; ${w}, ${R}`; break; }
        }
      }

      // Subordinators: add a comma after the subordinate clause when it starts the sentence
      const first=(s.match(/^\w+/)||[""])[0].toLowerCase();
      if(SUBORD.includes(first) && !/,/.test(s)){
        const tokens=s.split(/\s+/);
        const starters=["i","you","he","she","we","they","it","the","a","an","this","that","these","those","many","most","some"];
        let ins=-1; for(let i=3;i<Math.min(tokens.length,20);i++){ if(starters.includes(tokens[i]?.toLowerCase())){ ins=i; break; } }
        if(ins>-1){ tokens.splice(ins,0,","); s=tokens.join(" "); }
      }

      // FANBOYS: ensure comma before cj when both sides are clauses
      for(const cj of FANBOYS){
        const pos=s.toLowerCase().indexOf(` ${cj} `);
        if(pos>-1 && !new RegExp(`,\\s+${cj}\\b`,"i").test(s)){
          const L=s.slice(0,pos).trim(), R=s.slice(pos+cj.length+2).trim();
          if(hasFiniteVerb(L) && hasFiniteVerb(R)){
            s = L.replace(/\s+$/,"") + ", " + cj + " " + R.replace(/^,?\s*/,"");
          }
        }
      }
      return s+(end||"");
    });
    const bc=out; out=punctClauses(out);
    if(out!==bc) notes.push(t('changes.inserted_clause_punct') || "Inserted clause punctuation.");

    // Final stop
    if(!/[.!?]$/.test(out)){
      out+=".";
      notes.push(t('changes.added_final_stop') || "Added final full stop.");
    }

    const alts=buildAlternatives(out, lvl);
    return { out:out.trim(), notes, alts };
  }

  function detectIntensifierNotes(original, corrected) {
    const notes = [];
    const INT_RE = /\b(very|really|truly|actually|extremely)\s+([A-Za-z'-]+)\b/gi;
    const orig=[]; let m;
    while ((m=INT_RE.exec(original)) !== null) { orig.push({ intensifier:m[1], base:m[2] }); }
    if (!orig.length) return notes;

    const lc=corrected.toLowerCase();
    orig.forEach(({ intensifier, base }) => {
      const phrase = `${intensifier} ${base}`.toLowerCase();
      if (!lc.includes(phrase)) {
        const baseStillThere = new RegExp(`\\b${base.replace(/[.*+?^${}()|[\\]\\\\]/g,"\\$&")}\\b`,"i").test(corrected);
        if (baseStillThere) {
          const tpl = t('changes.removed_intensifier_kept_base') || "Removed intensifier “{i}” and kept “{b}” for formality.";
          notes.push(tpl.replace('{i}', intensifier).replace('{b}', base));
        } else {
          const tpl = t('changes.removed_intensifier_upgraded') || "Removed intensifier “{i}” and upgraded vocabulary.";
          notes.push(tpl.replace('{i}', intensifier));
        }
      }
    });
    return notes;
  }

  /* ========= Quick rubrics ========= */
  function renderB2Rubric(text, lvl){
    const card=document.getElementById('b2RubricCard'); const box=document.getElementById('b2Rubric'); if(!card||!box) return;
    if(lvl!=='B2'){ card.style.display='none'; box.innerHTML=''; return; }
    card.style.display='';
    const wc=(String(text).trim().match(/\b[\w’'-]+\b/g)||[]).length; const okWc=wc>=140 && wc<=190;
    const linkers=(text.match(/\b(however|in addition|therefore|on the other hand|for example)\b/gi)||[]).length;
    const contractions=(text.match(/\b(I'm|it's|don't|can't|won't|they're|we're)\b/gi)||[]).length;
    let html='';
    html += okWc? `✅ Word count 140–190 (${wc}).` : `⚠️ Word count ${wc} (target 140–190).`;
    html += '<br>' + (linkers>=2 ? '✅ Cohesive devices present.' : '⚠️ Add clear linkers (however, for example, therefore).');
    html += '<br>' + (contractions===0 ? '✅ Formality appropriate (no contractions).' : '⚠️ Avoid contractions in formal essays.');
    box.innerHTML = html;
  }
  function renderC1Rubric(text, lvl){
    const card=document.getElementById('c1RubricCard'); const box=document.getElementById('c1Rubric'); if(!card||!box) return;
    if(lvl!=='C1'){ card.style.display='none'; box.innerHTML=''; return; }
    card.style.display='';
    const wc=(String(text).trim().match(/\b[\w’'-]+\b/g)||[]).length; const okWc=wc>=220 && wc<=260;
    const devices=(text.match(/\b(nevertheless|consequently|moreover|whereas|although)\b/gi)||[]).length;
    const stance=(text.match(/\b(on balance|overall|it seems|it appears|this suggests)\b/gi)||[]).length;
    let html='';
    html += okWc? `✅ Word count 220–260 (${wc}).` : `⚠️ Word count ${wc} (target 220–260).`;
    html += '<br>' + (devices>=2 ? '✅ Variety of cohesive devices.' : '⚠️ Use a wider range of cohesive devices (nevertheless, consequently, whereas…).');
    html += '<br>' + (stance>=1 ? '✅ Clear analytical stance.' : '⚠️ Signal stance with evaluative language (on balance, it appears…).');
    box.innerHTML = html;
  }
  function renderC2Rubric(text, lvl){
    const card=document.getElementById('c2RubricCard'); const box=document.getElementById('c2Rubric'); if(!card||!box) return;
    if(lvl!== 'C2'){ card.style.display='none'; box.innerHTML=''; return; }
    card.style.display='';
    const wc=(String(text).trim().match(/\b[\w’'-]+\b/g)||[]).length; const okWc=wc>=240 && wc<=280;
    const evalHits=(text.match(/\b(however|although|whereas|nonetheless|nevertheless|assumption|evidence|premise|contend|maintain|plausible|implicat(?:e|ion)|suggests?)\b/gi)||[]).length;
    const concessive=(text.match(/\b(although|though|whereas|while)\b/gi)||[]).length;
    const advs=(text.match(/\b(however|therefore|consequently|moreover|nevertheless|thus)\b/gi)||[]).length;
    const firstP=(text.match(/\b(I|we|my|our)\b/g)||[]).length;
    const repeats=(function(){
      const words=String(text).toLowerCase().match(/\b[^\d\W][\w’'-]*\b/g)||[];
      const stop=new Set('the a an and or but so to of in on for with as by at from that which this these those it they we i you he she one ones be is are was were been being have has had do does did'.split(' '));
      const counts={}; words.forEach(w=>{ if(w.length<4||stop.has(w)) return; counts[w]=(counts[w]||0)+1; });
      return Object.entries(counts).filter(([,c])=>c>=3).slice(0,5);
    })();
    let html='';
    html += okWc? `✅ Word count within 240–280 (${wc}).` : `⚠️ Word count ${wc} (target 240–280).`;
    html += '<br>' + (evalHits>=2 ? '✅ Evidence of evaluation/stance language.' : '⚠️ Add more evaluative language (e.g., “however”, “it is plausible that”, “this assumes…”).');
    html += '<br>' + ((concessive+advs)>=3 ? '✅ Cohesion variety (concessives/adverbials).' : '⚠️ Increase cohesion variety (try concessives, cause–effect, and summative devices).');
    html += '<br>' + (firstP<=2 ? '✅ Neutral/academic stance maintained.' : '⚠️ Consider a more impersonal stance (limit first-person).');
    if(repeats.length){ html += '<br>⚠️ Repetition: ' + repeats.map(([w,c])=>w+'×'+c).join(', ') + '. Try precise alternatives.'; }
    box.innerHTML = html;
  }
  function renderAllRubrics(text, lvl){
    renderB2Rubric(text, lvl);
    renderC1Rubric(text, lvl);
    renderC2Rubric(text, lvl);
  }

  /* ========= Sentence-type analysis (scaffold) ========= */
  function analyzeSentenceTypes(text){
    // Heuristic placeholder — replace with your classifier.
    const sents = String(text).split(/(?<=[.!?])\s+/).filter(Boolean);
    const fanboys = /\s(?:for|and|nor|but|or|yet|so)\s/i;
    const subord  = /\b(although|though|because|since|when|while|if|unless|after|before|once|whereas|as)\b/i;
    const conjAdv = /;\s*(however|therefore|moreover|nevertheless|consequently|furthermore|nonetheless|accordingly|thus|otherwise|meanwhile|instead|still)\s*,/i;

    const counts = { simple:0, compound:0, complex:0, compoundComplex:0 };
    const examples = { simple:[], compound:[], complex:[], compoundComplex:[] };

    sents.forEach(s=>{
      const hasFan = fanboys.test(s);
      const hasSub = subord.test(s);
      const hasAdv = conjAdv.test(s);
      const hasTwoClauses = hasFan || hasAdv;
      const hasSubClause  = hasSub;

      let type='simple';
      if (hasTwoClauses && hasSubClause) type='compoundComplex';
      else if (hasTwoClauses) type='compound';
      else if (hasSubClause) type='complex';
      counts[type]++; if (examples[type].length<2) examples[type].push(s.trim());
    });

    return { total:sents.length, counts, examples };
  }
  function renderSentenceTypes(text){
    const card = document.getElementById('sentTypeCard');
    const box  = document.getElementById('sentTypesBox');
    if(!card || !box) return;
    if(!text || !text.trim()){ card.style.display='none'; box.innerHTML=''; return; }
    card.style.display='';
    const a = analyzeSentenceTypes(text);
    const ttitle = t('sent.types_title') || 'Sentence type analysis';
    const lines = [
      `📝 ${ttitle}`,
      `Total sentences: ${a.total}`,
      `• Simple: ${a.counts.simple}` + (a.examples.simple[0] ? ` — e.g. “${escapeHtml(a.examples.simple[0])}”` : ''),
      `• Compound: ${a.counts.compound}` + (a.examples.compound[0] ? ` — e.g. “${escapeHtml(a.examples.compound[0])}”` : ''),
      `• Complex: ${a.counts.complex}` + (a.examples.complex[0] ? ` — e.g. “${escapeHtml(a.examples.complex[0])}”` : ''),
      `• Compound-complex: ${a.counts.compoundComplex}` + (a.examples.compoundComplex[0] ? ` — e.g. “${escapeHtml(a.examples.compoundComplex[0])}”` : '')
    ];
    box.innerHTML = lines.join('<br>');
  }

  /* ========= Corrector main ========= */
  function updateWordPills(){
    const lvl=document.getElementById('levelSelect').value;
    const input=(document.getElementById('inputText').value.trim().match(/\b[\w’'-]+\b/g)||[]).length;
    const output=(document.getElementById('outputText').value.trim().match(/\b[\w’'-]+\b/g)||[]).length;
    document.getElementById('inWC').textContent = `Input: ${input} words`;
    const outP=document.getElementById('outWC'); outP.textContent = `Output: ${output} words`; outP.className='pill';
    const tip=document.getElementById('essayTip'); if (tip){ tip.textContent = (lvl==='B2'?'Target 140–190 (B2 essay)': lvl==='C2'?'Target 240–280 (C2 essay)':'Target 220–260 (C1 essay)'); }
    if (lvl==='B2'){ if(output>=140 && output<=190) outP.classList.add('ok'); else if (output>0) outP.classList.add('warn'); }
    if (lvl==='C1'){ if(output>=220 && output<=260) outP.classList.add('ok'); else if (output>0) outP.classList.add('warn'); }
    if (lvl==='C2'){ if(output>=240 && output<=280) outP.classList.add('ok'); else if (output>0) outP.classList.add('warn'); }
  }
  ['inputText','outputText'].forEach(id=>{ document.addEventListener('input',(e)=>{ if(e.target && e.target.id===id) updateWordPills(); }); });

  function renderAlternatives(currentText, alts, level) {
    const box = document.getElementById("altList");
    if (!alts.length) { box.innerHTML = "<span class='hint'>No suggestions for this text.</span>"; return; }
    box.innerHTML = "";
    alts.forEach(({ simple, options }) => {
      const sec = document.createElement("div"); sec.className = "alt-section";
      const intensifiers = ["very","really","truly","actually","extremely"];
      const label = intensifiers.includes(simple.toLowerCase()) ? `“${simple}” (intensifier removed) → stronger choices:` : `“${simple}” → consider:`;
      const h = document.createElement("h4"); h.textContent = label; sec.appendChild(h);
      options.slice(0, level === "C1" ? 6 : level === "C2" ? 8 : 4).forEach(opt => {
        const chip = document.createElement("button"); chip.className = "chip"; chip.textContent = opt;
        chip.onclick = () => {
          const re = wordRe(simple);
          const replaced = (document.getElementById("outputText").value || currentText).replace(re, m => {
            const cap = m[0] === m[0].toUpperCase();
            return cap ? opt[0].toUpperCase() + opt.slice(1) : opt;
          });
          document.getElementById("outputText").value = replaced;
          renderPreviewAndPositions(replaced, level);
          renderSentenceTypes(replaced);
          updateWordPills();
        };
        sec.appendChild(chip);
      });
      box.appendChild(sec);
    });
  }

  async function runCorrection(){
    const input = document.getElementById("inputText").value.trim();
    const lvl   = document.getElementById("levelSelect").value;
    const formal= document.getElementById("formalToggle").checked;
    const useAI = document.getElementById("aiToggle").checked && typeof window.AI_ENDPOINT === "string" && window.AI_ENDPOINT.startsWith("https://");
    const outBox=document.getElementById("outputText"); const notesBox=document.getElementById("notes"); const altBox=document.getElementById("altList");
    if (!input){
      outBox.value=""; notesBox.innerHTML="<b>Changes:</b><br><span class='hint'>No input provided.</span>";
      altBox.innerHTML=""; document.getElementById('outputPreview').innerHTML=""; document.getElementById('positions').innerHTML="";
      renderSentenceTypes(""); renderAllRubrics("", lvl); updateWordPills(); return;
    }
    notesBox.innerHTML = "<b>Changes:</b><br><span class='hint'>Processing…</span>"; altBox.innerHTML = "<span class='hint'>Processing…</span>"; outBox.value = "";
    document.getElementById('outputPreview').innerHTML=""; document.getElementById('positions').innerHTML="";

    try{
      const { out, notes, alts } = correctLocal(input, lvl);
      outBox.value = out;
      notesBox.innerHTML = "<b>" + (t?.('preview.changes_title') || "Changes:") + "</b><br>" +
                           (notes.length ? notes.map(n=>"• "+escapeHtml(n)).join("<br>")
                                         : "(" + (t?.('preview.changes_wait') || "No major changes") + ")");
      renderAlternatives(out, alts, lvl);
      renderPreviewAndPositions(out, lvl);
      renderAllRubrics(out, lvl);
      renderSentenceTypes(out);
      updateWordPills();
    } catch(e){
      notesBox.innerHTML = `<b>${t?.('errors.generic') || "Local corrector failed:"}</b> ${escapeHtml(e.message)}`;
      outBox.value = input;
      renderSentenceTypes(input);
      renderAllRubrics(input, lvl);
      updateWordPills();
    }
  }

  function clearAll(){
    document.getElementById("inputText").value="";
    document.getElementById("outputText").value="";
    document.getElementById("outputPreview").innerHTML="";
    document.getElementById("positions").innerHTML="";
    document.getElementById("notes").innerHTML =
      "<b>" + (t?.('preview.changes_title') || "Changes:") + "</b><br>" +
      "<span class='hint'>" + (t?.('status.cleared') || "Cleared.") + "</span>";
    document.getElementById("altList").innerHTML =
      t?.('vocab.alternatives_wait') || "After correction, suggested upgrades will appear here (especially for C1/C2).";
    hiddenIds.clear(); currentMarks=[]; window._lastSignature="";
    ['b2RubricCard','c1RubricCard','c2RubricCard'].forEach(id=>{ const el=document.getElementById(id); if(el) el.style.display='none'; });
    ['b2Rubric','c1Rubric','c2Rubric'].forEach(id=>{ const el=document.getElementById(id); if(el) el.innerHTML=''; });
    const st=document.getElementById('sentTypeCard'); if(st){ st.style.display='none'; document.getElementById('sentTypesBox').innerHTML=''; }
    updateWordPills();
  }

  async function pasteFromClipboard(){
    const ta=document.getElementById("inputText");
    try{
      const text=await navigator.clipboard.readText();
      if(text){
        const start=ta.selectionStart ?? ta.value.length, end=ta.selectionEnd ?? ta.value.length;
        ta.value = ta.value.slice(0,start)+text+ta.value.slice(end);
        ta.focus(); ta.selectionStart=ta.selectionEnd=start+text.length; updateWordPills();
      } else alert(t?.('status.clipboard_empty') || "Your clipboard is empty.");
    }catch(e){
      alert(t?.('errors.clipboard_blocked') || "Browser blocked clipboard. Try Ctrl/Cmd+V on desktop, or long-press → Paste on mobile.");
    }
  }

  function downloadPDF(){
    try{
      const { jsPDF } = window.jspdf || {}; if(!jsPDF){ alert(t?.('errors.pdf_lib_failed') || "PDF library failed to load."); return; }
      const doc=new jsPDF({ unit:"pt", format:"a4" }); const margin=48; let y=margin;
      const title = t?.('export.title') || "EssayCoach – Corrected Output";
      doc.setFont("Helvetica","bold"); doc.setFontSize(14); doc.text(title, margin, y); y+=20;
      doc.setFont("Helvetica","normal"); doc.setFontSize(12);
      const lines=doc.splitTextToSize(document.getElementById("outputText").value || "(empty)", 595-margin*2);
      doc.text(lines, margin, y);
      doc.save("essay-corrected.pdf");
    }catch(e){ alert((t?.('errors.pdf_failed') || "Could not create PDF: ") + e.message); }
  }

  /* ========= Punctuation Guide (safe overwrite) ========= */
  (function () {
    window.PUNCT_GUIDE = String.raw`…(unchanged huge guide)…`;
    window.PUNCT_RULES = [window.PUNCT_GUIDE];

    window.renderPunctRules = function(){
      const box = document.getElementById('punctRules');
      if (!box) return;
      box.style.whiteSpace = "pre-wrap";
      box.style.fontFamily = "inherit";
      box.textContent = window.PUNCT_GUIDE;
    };

    window.copyPunctRules = function(){
      navigator.clipboard?.writeText(window.PUNCT_GUIDE);
      alert(t?.('status.punct_copied') || "Punctuation guide copied.");
    };

    window.exportPunctPDF = function(){
      const { jsPDF } = window.jspdf || {};
      if (!jsPDF){ alert(t?.('errors.pdf_lib_failed') || "PDF library failed to load."); return; }

      const doc = new jsPDF({ unit: "pt", format: "a4" });
      const margin = 48;
      const pageW = doc.internal.pageSize.getWidth();
      const pageH = doc.internal.pageSize.getHeight();
      let y = margin;

      const pdfTitle = t?.('punct.pdf_title') || "Punctuation & Sentence Building";
      doc.setFont("Helvetica","bold"); doc.setFontSize(16);
      doc.text(pdfTitle, margin, y); y += 24;

      doc.setFont("Helvetica","normal"); doc.setFontSize(12);
      const lines = doc.splitTextToSize(window.PUNCT_GUIDE, pageW - margin*2);
      const lh = 14;

      lines.forEach(line => {
        if (y > pageH - margin) { doc.addPage(); y = margin; }
        doc.text(line, margin, y);
        y += lh;
      });

      const fname = t?.('punct.pdf_filename') || "punctuation-guide.pdf";
      doc.save(fname);
    };

    window.openPunctGuide = function(){
      document.getElementById('punctGuideBody').textContent = window.PUNCT_GUIDE;
      document.getElementById('punctGuideModal').style.display = 'block';
    };
    window.closePunctGuide = function(){
      document.getElementById('punctGuideModal').style.display = 'none';
    };
  })();

  /* ========= Scaffolds renderer ========= */
  function renderScaffold(){
    const lvl = document.getElementById('scLevel').value;
    if (lvl==='C2'){ const st=document.getElementById('scType'); if (st && st.value!=='essay'){ st.value='essay'; } }
    const typ = document.getElementById('scType').value;
    const d = SCAFFOLDS[lvl][typ];
    document.getElementById('scMoves').innerHTML = d.moves.map(m => `<li>${escapeHtml(m)}</li>`).join('');
    document.getElementById('scOpener').textContent = d.opener;
    document.getElementById('scTips').innerHTML = d.tips.map(ti => `<li>${escapeHtml(ti)}</li>`).join('');
    if (document.getElementById('guideOverlay').style.display === 'flex') { renderGuideExample(); }
  }
  function copyScaffold(){
    const list=document.getElementById('scMoves');
    const items=[...list.querySelectorAll('li')].map(li=>`• ${li.textContent}`);
    navigator.clipboard?.writeText(items.join("\n"));
    alert(t('status.scaffold_copied') || "Scaffold copied.");
  }
  function copyOpener(){
    const text=document.getElementById('scOpener').textContent || '';
    navigator.clipboard?.writeText(text);
    alert(t('status.opener_copied') || "Opener copied.");
  }
  function exportScaffoldPDF(){
    const { jsPDF } = window.jspdf || {}; if (!jsPDF){ alert(t('errors.pdf_lib_failed') || "PDF library failed to load."); return; }
    const doc=new jsPDF({ unit:"pt", format:"a4" }); const margin=48; let y=margin;
    const level=document.getElementById('scLevel').value; const type=document.getElementById('scType').value;
    doc.setFont("Helvetica","bold"); doc.setFontSize(16); doc.text(`Scaffold – ${level} ${type[0].toUpperCase()+type.slice(1)}`, margin, y); y+=18;
    doc.setFont("Helvetica","normal"); doc.setFontSize(12);
    const moves=[...document.querySelectorAll('#scMoves li')].map((li,i)=>`${i+1}) ${li.textContent}`);
    doc.text(doc.splitTextToSize(moves.join("\n"), 595-margin*2), margin, y); y+=18;
    doc.text("Opener:", margin, y); y+=14;
    doc.text(doc.splitTextToSize(document.getElementById('scOpener').textContent||'', 595-margin*2), margin, y); y+=18;
    doc.text("Tips:", margin, y); y+=14;
    const tips=[...document.querySelectorAll('#scTips li')].map((li,i)=>`${i+1}) ${li.textContent}`);
    doc.text(doc.splitTextToSize(tips.join("\n"), 595-margin*2), margin, y);
    doc.save("scaffold.pdf");
  }

  /* ---------- Part 2: config & helpers ---------- */
  function p2StyleFor(lvl, type){
    const baseWC = (lvl==='B2')?'140–190': (lvl==='C2')?'240–280':'220–260';
    const lvlTag = (lvl==='B2')?'B2 First': (lvl==='C2')?'C2 Proficiency':'C1 Advanced';
    if(type==='letter') return `${lvlTag} Letter/Email: formal register; clear salutation and closing; state purpose early; organise developed points; polite requests/hedging; suitable sign-off; aim ${baseWC} words.`;
    if(type==='proposal') return `${lvlTag} Proposal: formal register; rationale → objectives → plan → benefits; headings/bullets acceptable; actionable recommendations with justification; aim ${baseWC} words.`;
    if(type==='report') return `${lvlTag} Report: objective/impersonal register; purpose & methods → findings → analysis → prioritised recommendations; headings encouraged; aim ${baseWC} words.`;
    return `${lvlTag} Review: neutral/semi-formal; hook → brief overview (no spoilers) → evaluation of craft/themes with examples → verdict & audience; aim ${baseWC} words.`;
  }
  function p2TargetForLevel(lvl){
    if (lvl === 'B2') return { min:140, max:190, label: t('part2.target') || 'Target — 140–190 (B2)' };
    if (lvl === 'C2') return { min:240, max:280, label: t('part2.target') || 'Target — 240–280 (C2)' };
    return { min:220, max:260, label: t('part2.target') || 'Target — 220–260 (C1)' };
  }
  function _normalizeForCompare(s){ return String(s||"").replace(/[\u2018\u2019\u2032]/g,"'").replace(/[\u201C\u201D\u2033]/g,'"').replace(/\u00A0/g," ").replace(/\s+/g," ").trim().toLowerCase(); }
  function _aiMadeNoChanges(input, output){ return _normalizeForCompare(input) === _normalizeForCompare(output); }

  function updatePart2WordcountPills(){
    const lvl  = document.getElementById('p2Level').value;
    const inWC  = (document.getElementById('p2Input').value.trim().match(/\b[\w’'-]+\b/g)  || []).length;
    const outWC = (document.getElementById('p2Output').value.trim().match(/\b[\w’'-]+\b/g) || []).length;
    const inLabel  = (t('io.input_words')  || 'Input: {n} words

          const inLabel  = (t('io.input_words')  || 'Input: {n} words').replace('{n}', inWC);
    const outLabel = (t('io.output_words') || 'Output: {n} words').replace('{n}', outWC);

    const tEl = document.getElementById('p2TargetWC');
    const pills = p2TargetForLevel(lvl); // {min,max,label}

    const inEl  = document.getElementById('p2InWC');
    const outEl = document.getElementById('p2OutWC');

    if (inEl)  inEl.textContent  = inLabel;
    if (outEl) {
      outEl.textContent = outLabel;
      outEl.className = 'pill';
      if (outWC > 0 && (outWC < pills.min || outWC > pills.max)) outEl.classList.add('warn');
      if (outWC >= pills.min && outWC <= pills.max) outEl.classList.add('ok');
    }
    if (tEl) tEl.textContent = pills.label;
  }

  // Live update for Part 2 input/output
  ['p2Input','p2Output'].forEach(id=>{
    document.addEventListener('input',(e)=>{
      if(e.target && e.target.id===id) updatePart2WordcountPills();
    });
  });

  // Clause-highlighting hooks for Part 2 (reuse Part 1 helpers if present)
  function p2FindConjAdvMatches(text){ return (typeof findConjAdvMatches==='function') ? findConjAdvMatches(text) : []; }
  function p2FindFanboysMatches(text){ return (typeof findFanboysMatches==='function') ? findFanboysMatches(text) : []; }

  function p2CoachClauseNotes(corrected, level){
    const show = document.getElementById('p2CoachNotes')?.checked !== false;
    if (!show || !corrected) return { notes: [], marks: [] };

    const cadv = p2FindConjAdvMatches(corrected);
    const fanb = p2FindFanboysMatches(corrected);
    const notes = [];

    cadv.forEach(({group,label,start,end})=>{
      if (group==='contrast') notes.push(`Used “${label?.trim?.()||''}” to join two clauses (C1 style) at chars ${start}–${end}.`);
      else if (group==='result') notes.push(`Used “${label?.trim?.()||''}” (result) at chars ${start}–${end}.`);
      else if (group==='addition') notes.push(`Used “${label?.trim?.()||''}” (addition) at chars ${start}–${end}.`);
    });
    fanb.forEach(({label,start,end})=>{ notes.push(`Coordinating join “${label?.trim?.()||''}” at ${start}–${end}.`); });

    let marks=[...cadv, ...fanb].sort((a,b)=>a.start-b.start);
    const filtered=[]; let lastEnd=-1, counter=1;
    marks.forEach(m=>{ if(m.start>=lastEnd){ m.id=`p2hl-${counter++}`; filtered.push(m); lastEnd=m.end; } });
    return { notes, marks: filtered };
  }

  function p2BuildHighlightedHTML(text, marks){
    if(!marks.length) return (typeof escapeHtml==='function' ? escapeHtml(text) : text).replace(/\n/g,'<br>');
    let html='', idx=0;
    for(const m of marks){
      const chunk = text.slice(idx, m.start);
      html += (typeof escapeHtml==='function' ? escapeHtml(chunk) : chunk).replace(/\n/g,'<br>');
      const inner = text.slice(m.start, m.end);
      const safe  = (typeof escapeHtml==='function' ? escapeHtml(inner) : inner);
      const title = (typeof escapeHtml==='function' ? escapeHtml(m.label?.trim?.()||'') : (m.label||''));
      html += `<mark class="hl" id="${m.id}" title="${title}">${safe}</mark>`;
      idx = m.end;
    }
    const tail = text.slice(idx);
    html += (typeof escapeHtml==='function' ? escapeHtml(tail) : tail).replace(/\n/g,'<br>');
    return html;
  }

  function p2RenderPreview(corrected, level){
    const lvl = level || document.getElementById('p2Level').value;
    const { notes: coach, marks } = p2CoachClauseNotes(corrected, lvl);

    const prev = document.getElementById('part2Preview');
    if (prev) prev.innerHTML = p2BuildHighlightedHTML(corrected, marks);

    const posBox = document.getElementById('p2Positions');
    if (posBox){
      if (!marks.length) posBox.innerHTML = "";
      else {
        const chips = marks.map(m=> `<a href="#" onclick="document.getElementById('${m.id}')?.scrollIntoView({behavior:'smooth',block:'center'});return false;">${m.start}–${m.end}</a>`).join(' ');
        posBox.innerHTML = `<b>${t('preview.marked_spans') || 'Marked spans:'}</b> ${chips}`;
      }
    }

    const notesBox = document.getElementById('part2Changes');
    if (notesBox && coach.length){
      if (!/Coach notes:/i.test(notesBox.innerHTML)) notesBox.innerHTML += "<br>";
      notesBox.innerHTML += "<br><b>Coach notes:</b><br>" + coach.map(n=>"• "+(typeof escapeHtml==='function'?escapeHtml(n):n)).join("<br>");
    }
  }

  function renderAlternativesP2(currentText, alts, level) {
    const box = document.getElementById("part2Vocab");
    if (!box) return;

    if (!alts || !alts.length) {
      box.innerHTML = `<span class='hint'>${t('part2.vocab_alts_wait') || 'After correction, suggested upgrades will appear here.'}</span>`;
      return;
    }
    box.innerHTML = "";
    alts.forEach(({ simple, options }) => {
      const sec = document.createElement("div"); sec.className = "alt-section";
      const h = document.createElement("h4");
      h.textContent = `“${simple}” → ${t('vocab.alternatives_title') || 'Consider alternatives:'}`;
      sec.appendChild(h);

      options.slice(0, level === "C1" ? 6 : level === "C2" ? 8 : 4).forEach(opt => {
        const chip = document.createElement("button"); chip.className = "chip"; chip.textContent = opt;
        chip.onclick = () => {
          if (typeof wordRe !== 'function') return;
          const re = wordRe(simple);
          const replaced = (document.getElementById("p2Output").value || currentText).replace(re, m => {
            const cap = m[0] === m[0].toUpperCase();
            return cap ? opt[0].toUpperCase() + opt.slice(1) : opt;
          });
          document.getElementById("p2Output").value = replaced;
          p2RenderPreview(replaced, level);
          updatePart2WordcountPills();
        };
        sec.appendChild(chip);
      });
      box.appendChild(sec);
    });
  }

  function p2GenreRubric(text, lvl, type){
    const checks=[];
    const wc = (String(text||'').match(/\b[\w’'-]+\b/g)||[]).length;
    const target = p2TargetForLevel(lvl);
    const okWC = wc>=target.min && wc<=target.max;

    checks.push(okWC
      ? `✅ ${(t('io.output_words') || 'Output: {n} words').replace('{n}', wc)}`
      : `⚠️ ${(t('io.output_words') || 'Output: {n} words').replace('{n}', wc)}; ${t('part2.target') || 'target'} ${target.min}–${target.max}.`
    );

    if(type==='letter'){
      checks.push(/\bDear\b/.test(text)?'✅ Salutation present.':'⚠️ Add an appropriate salutation (e.g., “Dear Ms X,”).');
      checks.push(/\bYours (faithfully|sincerely)\b/i.test(text)?'✅ Formal sign-off present.':'⚠️ Add a formal sign-off (“Yours sincerely/faithfully”).');
      checks.push(/\bI am writing\b|\bI would like to\b/i.test(text)?'✅ Purpose stated early.':'⚠️ State purpose early (“I am writing to…”).');
    } else if(type==='proposal'){
      const heads = /(Objective|Objectives|Plan|Benefits|Recommendation|Recommendations)/i.test(text);
      checks.push(heads?'✅ Structural headings detected.':'⚠️ Use clear sections (Objectives, Plan, Benefits, Recommendations).');
      checks.push(/\brecommend(ed|ation|ations)?\b|It is recommended\b/i.test(text)?'✅ Explicit recommendations.':'⚠️ Add explicit, actionable recommendations.');
    } else if(type==='report'){
      const sections = /(Findings|Analysis|Recommendations)/i.test(text);
      checks.push(sections?'✅ Findings/Analysis/Recommendations present.':'⚠️ Include Findings → Analysis → Recommendations.');
      checks.push(/\b(It is|There is|There are|was|were)\b/i.test(text)?'✅ Impersonal register appears.':'⚠️ Prefer an objective/impersonal register.');
    } else if(type==='review'){
      checks.push(/\b(recommend|worth|audience|viewers|readers)\b/i.test(text)?'✅ Verdict/audience indicated.':'⚠️ End with a clear verdict and audience.');
      checks.push(/\b(style|pacing|voice|theme|motif|character)\b/i.test(text)?'✅ Evaluation of craft/themes.':'⚠️ Evaluate craft/themes, not only plot.');
    }
    return checks.join('<br>');
  }

  function p2RenderRubric(text, lvl, type){
    const box = document.getElementById('part2Rubric');
    if (!box) return;
    box.innerHTML = p2GenreRubric(String(text||''), lvl, type);
  }

  async function runPart2Correction(){
    const input = document.getElementById("p2Input").value.trim();
    const lvl   = document.getElementById("p2Level").value;
    const type  = document.getElementById("p2Type").value;
    const formal= document.getElementById("p2Formal").checked;
    const useAI = document.getElementById("p2UseAI").checked && typeof window.AI_ENDPOINT === "string" && window.AI_ENDPOINT.startsWith("https://");

    const outBox   = document.getElementById("p2Output");
    const changes  = document.getElementById("part2Changes");
    const vocabBox = document.getElementById("part2Vocab");

    if (!input){
      outBox.value = "";
      changes.innerHTML = "<b>" + (t('preview.changes_title') || 'Changes:') + "</b><br><span class='hint'>" + (t('warn.no_text') || 'Paste your text to get started.') + "</span>";
      vocabBox.innerHTML = "<span class='hint'>" + (t('part2.vocab_alts_wait') || 'After correction, suggested upgrades will appear here.') + "</span>";
      document.getElementById('part2Preview').innerHTML = "";
      const pos = document.getElementById('p2Positions'); if (pos) pos.innerHTML="";
      updatePart2WordcountPills();
      return;
    }

    changes.innerHTML = "<b>" + (t('preview.changes_title') || 'Changes:') + "</b><br><span class='hint'>Processing…</span>";
    vocabBox.innerHTML = "<span class='hint'>Processing…</span>";
    outBox.value = "";
    document.getElementById('part2Preview').innerHTML = "";
    const pos = document.getElementById('p2Positions'); if (pos) pos.innerHTML="";

    if (useAI){
      try{
        const res = await fetch(window.AI_ENDPOINT, {
          method: "POST",
          headers: { "Content-Type":"application/json" },
          body: JSON.stringify({ text: input, level: lvl, formal, style: p2StyleFor(lvl, type), genre: type })
        });
        const raw = await res.text();
        if (!res.ok) {
          changes.innerHTML = `<b>AI call failed:</b> HTTP ${res.status}<br><pre style="white-space:pre-wrap">${escapeHtml(raw)}</pre><br><i>Using local rules instead.</i>`;
          throw new Error("AI HTTP "+res.status);
        }
        let data; try { data = JSON.parse(raw); } catch {
          changes.innerHTML = `<b>AI returned non-JSON:</b><br><pre style="white-space:pre-wrap">${escapeHtml(raw)}</pre><br><i>Using local rules instead.</i>`;
          throw new Error("AI non-JSON");
        }

        if (data && typeof data.corrected === 'string'){
          const aiOut = data.corrected;
          if (_aiMadeNoChanges(input, aiOut)){
            // fallback to local if AI made no edits
            const { out, notes, alts } = correctLocal(input, lvl);
            outBox.value = out;
            changes.innerHTML = "<b>" + (t('preview.changes_title') || 'Changes:') + " (local fallback – AI made no edits)</b><br>" +
              (notes.length ? notes.map(n=>"• "+escapeHtml(n)).join("<br>") : "("+(t('vocab.alternatives_wait')||'No major changes')+")");
            const fromAI = (data.alternatives && typeof data.alternatives==='object') ? data.alternatives : {};
            const fromLocal = buildAlternatives(out, lvl);
            const merged = mergeAlternatives(fromAI, fromLocal);
            renderAlternativesP2(out, merged, lvl);
            p2RenderPreview(out, lvl);
            p2RenderRubric(out, lvl, type);
            updatePart2WordcountPills();
            return;
          }

          outBox.value = aiOut;
          const baseNotes = Array.isArray(data.notes) ? data.notes : [];
          changes.innerHTML = "<b>" + (t('preview.changes_title') || 'Changes:') + " (AI)</b><br>" +
            (baseNotes.length ? baseNotes.map(n=>"• "+escapeHtml(n)).join("<br>") : "("+(t('vocab.alternatives_wait')||'none')+")");
          if (Array.isArray(data.replacements) && data.replacements.length){
            changes.innerHTML += "<br><b>Upgrades:</b><br>";
            data.replacements.forEach(r=>{ changes.innerHTML += "• Replaced “"+escapeHtml(r.from)+"” → “"+escapeHtml(r.to)+"”<br>"; });
          } else {
            const extra = detectIntensifierNotes(input, aiOut);
            if (extra.length) changes.innerHTML += "<br>" + extra.map(n => "• " + escapeHtml(n)).join("<br>");
          }
          const fromAI = (data.alternatives && typeof data.alternatives==='object') ? data.alternatives : {};
          const fromLocal = buildAlternatives(aiOut, lvl);
          const merged = mergeAlternatives(fromAI, fromLocal);
          renderAlternativesP2(aiOut, merged, lvl);
          p2RenderPreview(aiOut, lvl);
          p2RenderRubric(aiOut, lvl, type);
          updatePart2WordcountPills();
          return;
        } else {
          changes.innerHTML = `<b>AI response missing "corrected".</b><br><pre style="white-space:pre-wrap">${escapeHtml(raw)}</pre><br><i>Using local rules instead.</i>`;
          throw new Error('AI missing corrected');
        }
      } catch(e){
        // fall through to local
      }
    }

    // Local path
    try{
      const { out, notes, alts } = correctLocal(input, lvl);
      outBox.value = out;
      const title = t('preview.changes_title') || 'Changes:';
      const body = (notes.length ? notes.map(n=>"• "+escapeHtml(n)).join("<br>") : "("+(t('vocab.alternatives_wait')||'No major changes')+")");
      changes.innerHTML = "<b>"+title+" (local)</b><br>"+body;
      renderAlternativesP2(out, alts, lvl);
      p2RenderPreview(out, lvl);
      p2RenderRubric(out, lvl, type);
      updatePart2WordcountPills();
    } catch(e){
      changes.innerHTML = `<b>Local corrector failed:</b> ${escapeHtml(e.message)}`;
      outBox.value = input;
      updatePart2WordcountPills();
    }
  }

  function clearPart2(){
    (document.getElementById("p2Input")||{}).value="";
    (document.getElementById("p2Output")||{}).value="";
    const prev = document.getElementById("part2Preview"); if (prev) prev.innerHTML="";
    const pos  = document.getElementById("p2Positions");  if (pos)  pos.innerHTML="";
    const ch   = document.getElementById("part2Changes");
    if (ch) ch.innerHTML = "<b>"+(t('preview.changes_title')||'Changes:')+"</b><br><span class='hint'>"+(t('btn.clear')||'Cleared')+".</span>";
    const vb   = document.getElementById("part2Vocab");
    if (vb) vb.innerHTML = (t('part2.vocab_alts_wait') || 'After correction, suggested upgrades will appear here.');
    updatePart2WordcountPills();
  }

  async function pastePart2(){
    const ta=document.getElementById("p2Input");
    try{
      const text=await navigator.clipboard.readText();
      if(text){
        const start=ta.selectionStart ?? ta.value.length, end=ta.selectionEnd ?? ta.value.length;
        ta.value = ta.value.slice(0,start)+text+ta.value.slice(end);
        ta.focus(); ta.selectionStart=ta.selectionEnd=start+text.length; updatePart2WordcountPills();
      } else alert(t('warn.no_text') || "Your clipboard is empty.");
    }catch(e){ alert(t('errors.clipboard_blocked') || "Browser blocked clipboard. Try Ctrl/Cmd+V or long-press → Paste."); }
  }

  function downloadPart2PDF(){
    try{
      const { jsPDF } = window.jspdf || {}; if(!jsPDF){ alert(t('errors.pdf_lib_failed') || "PDF library failed to load."); return; }
      const doc=new jsPDF({ unit:"pt", format:"a4" }); const margin=48; let y=margin;
      doc.setFont("Helvetica","bold"); doc.setFontSize(14);
      doc.text((t('export.title') || "Correction report") + " – Part 2", margin, y); y+=20;
      doc.setFont("Helvetica","normal"); doc.setFontSize(12);
      const text = document.getElementById("p2Output").value || "("+(t('warn.no_text')||'empty')+")";
      const lines=doc.splitTextToSize(text, 595-margin*2);
      doc.text(lines, margin, y);
      doc.save("part2-corrected.pdf");
    }catch(e){ alert((t('errors.pdf_failed') || "Could not create PDF: ") + e.message); }
  }

  /* ===== Shared timer (i18n) ===== */
  let _timer = null, _until = 0;
  function startTimer(minutes = 45){
    _until = Date.now() + minutes*60*1000;
    if (_timer) clearInterval(_timer);
    const paint = () => {
      const left = Math.max(0, _until - Date.now());
      const m = String(Math.floor(left/60000)).padStart(2,'0');
      const s = String(Math.floor((left%60000)/1000)).padStart(2,'0');
      const label = (window.t?.('io.timer_label') || 'Timer: {m}:{s}')
        .replace('{m}', m).replace('{s}', s);
      const main = document.getElementById('timer');   if (main) main.textContent = label;
      const p2t  = document.getElementById('p2Timer'); if (p2t)  p2t.textContent  = label;
      if (left <= 0) { clearInterval(_timer); _timer = null; }
    };
    paint(); _timer = setInterval(paint, 500);
  }

  /* ===== Init / boot ===== */
  try { renderScaffold?.(); } catch {}
  try { renderPunctRules?.(); } catch {}

  window.addEventListener('load', () => {
    // AI toggle (Part 1)
    const aiBox = document.getElementById('aiToggle');
    if (aiBox) {
      const hasEndpoint = typeof window.AI_ENDPOINT === "string" && window.AI_ENDPOINT.startsWith("https://");
      aiBox.checked = hasEndpoint;
      aiBox.disabled = !hasEndpoint;
      aiBox.title = hasEndpoint
        ? (window.t?.('hint.ai_enabled') || "Uses your Worker (AI); falls back to local rules.")
        : (window.t?.('hint.ai_disabled') || "Set window.AI_ENDPOINT to enable AI corrections.");
    }

    // AI toggle (Part 2)
    const p2Ai = document.getElementById('p2UseAI');
    if (p2Ai){
      const hasEndpoint = typeof window.AI_ENDPOINT === "string" && window.AI_ENDPOINT.startsWith("https://");
      p2Ai.checked = hasEndpoint;
      p2Ai.disabled = !hasEndpoint;
      if (!p2Ai.title) p2Ai.title = hasEndpoint
        ? (window.t?.('hint.ai_enabled') || "Uses your Worker (AI); falls back to local rules.")
        : (window.t?.('hint.ai_disabled') || "Set window.AI_ENDPOINT to enable AI corrections.");
    }

    // Hash routing
    if (location.hash === '#corrector')      { try{ showTab('corrector'); }catch{} }
    else if (location.hash === '#punct')     { try{ showTab('punct'); }catch{} }
    else if (location.hash === '#part2')     { try{ showPart2(); }catch{} }
    else                                     { try{ showTab('scaffolds'); }catch{} }

    // Wordcount pills for Part 1 + Part 2
    try { updateWordPills?.(); } catch {}
    try { updatePart2WordcountPills?.(); } catch {}
  });

  // Failsafe tab wiring
  (function () {
    const tSc = document.getElementById('tab-scaffolds');
    const tCo = document.getElementById('tab-corrector');
    const tPu = document.getElementById('tab-punct');
    const tP2 = document.getElementById('tab-part2');

    function safeShow(w) {
      try { if (w==='part2') showPart2(); else showTab(w); }
      catch {
        const vs = document.getElementById('view-scaffolds');
        const vc = document.getElementById('view-corrector');
        const vp = document.getElementById('view-punct');
        const v2 = document.getElementById('view-part2');
        if (vs && vc && vp && v2){
          vs.style.display = (w==='scaffolds') ? '' : 'none';
          vc.style.display = (w==='corrector') ? '' : 'none';
          vp.style.display = (w==='punct') ? '' : 'none';
          v2.style.display = (w==='part2') ? '' : 'none';
        }
      }
    }
    tSc?.addEventListener('click', () => safeShow('scaffolds'));
    tCo?.addEventListener('click', () => safeShow('corrector'));
    tPu?.addEventListener('click', () => safeShow('punct'));
    tP2?.addEventListener('click', () => safeShow('part2'));
  })();
  </script>

  <!-- App bundle (kept) -->
  <script src="/essay-coach-instant/assets/app.bundle.js" defer></script>
</body>
</html>
